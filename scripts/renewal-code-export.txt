// ============================================================================
// FILE: src/types/renewal.types.ts
// ============================================================================

/**
 * Renewal Review Types
 * ====================
 * Type definitions for the IVANS AL3 renewal review module.
 */

// =============================================================================
// AL3 TRANSACTION TYPES
// =============================================================================

/**
 * Parsed header from an AL3 transaction (quick scan, no full parse).
 */
export interface AL3TransactionHeader {
  transactionType: string; // e.g., 'RWL', 'RWQ', 'NBS', 'END'
  policyNumber: string;
  carrierCode: string; // NAIC code
  carrierName?: string;
  lineOfBusiness?: string;
  effectiveDate?: string; // YYYYMMDD
  expirationDate?: string; // YYYYMMDD
  insuredName?: string;
}

/**
 * Fully parsed AL3 transaction.
 */
export interface AL3ParsedTransaction {
  header: AL3TransactionHeader;
  coverages: AL3Coverage[];
  vehicles: AL3Vehicle[];
  drivers: AL3Driver[];
  locations: AL3Location[];
  remarks: string[];
  claims: AL3Claim[];
  endorsementRecords: AL3Endorsement[];
  discountRecords: AL3Discount[];
  mortgagees: AL3Mortgagee[];
  insuredAddress?: AL3Location;
  insuredEmail?: string;
  insuredPhone?: string;
  rawContent: string;
  parseConfidence: number; // 0-1
  // Total premium from 5BPI record (policy-level, authoritative)
  totalPremium?: number;
}

export interface AL3Coverage {
  code: string;
  description?: string;
  limit?: string;
  limitAmount?: number;
  deductible?: string;
  deductibleAmount?: number;
  premium?: number;
}

export interface AL3Vehicle {
  vin?: string;
  year?: number;
  make?: string;
  model?: string;
  usage?: string;
  garageZip?: string;
  coverages: AL3Coverage[];
}

export interface AL3Driver {
  name?: string;
  dateOfBirth?: string;
  licenseNumber?: string;
  licenseState?: string;
  relationship?: string;
  isExcluded?: boolean;
}

export interface AL3Location {
  number?: string;
  address?: string;
  city?: string;
  state?: string;
  zip?: string;
}

export interface AL3Discount {
  code: string;
  description?: string;
  amount?: number;
  percent?: number;
}

export interface AL3Claim {
  claimNumber?: string;
  claimDate?: string;
  claimType?: string;
  amount?: number;
  status?: string;
}

export interface AL3Endorsement {
  code: string;
  description?: string;
  effectiveDate?: string;
  premium?: number;
}

export interface AL3Mortgagee {
  interestType?: string; // LH=Lienholder, MS=Mortgagee, CN=Co-Named
  name?: string;
  loanNumber?: string;
  address?: string;
  city?: string;
  state?: string;
  zip?: string;
}

// =============================================================================
// CANONICAL SNAPSHOT TYPES
// =============================================================================

/**
 * Normalized coverage (carrier-agnostic).
 */
export interface CanonicalCoverage {
  type: string; // e.g., 'bodily_injury', 'property_damage', 'collision'
  description: string;
  limit?: string;
  limitAmount?: number;
  deductible?: string;
  deductibleAmount?: number;
  premium?: number;
}

/**
 * Normalized vehicle.
 */
export interface CanonicalVehicle {
  vin?: string;
  year?: number;
  make?: string;
  model?: string;
  usage?: string;
  coverages: CanonicalCoverage[];
}

/**
 * Normalized driver.
 */
export interface CanonicalDriver {
  name?: string;
  dateOfBirth?: string;
  licenseNumber?: string;
  licenseState?: string;
  relationship?: string;
  isExcluded?: boolean;
}

/**
 * Normalized discount.
 */
export interface CanonicalDiscount {
  code: string;
  description: string;
  amount?: number;
  percent?: number;
}

/**
 * Normalized claim.
 */
export interface CanonicalClaim {
  claimNumber?: string;
  claimDate?: string;
  claimType?: string;
  amount?: number;
  status?: string;
}

/**
 * Normalized endorsement.
 */
export interface CanonicalEndorsement {
  code: string;
  description: string;
  effectiveDate?: string;
  premium?: number;
}

/**
 * Property context for homeowners risk evaluation.
 */
export interface PropertyContext {
  roofAge?: number;
  roofType?: string;
  yearBuilt?: number;
  constructionType?: string;
}

/**
 * Renewal offer snapshot (from AL3).
 */
export interface RenewalSnapshot {
  insuredName?: string;
  insuredAddress?: string;
  insuredCity?: string;
  insuredState?: string;
  insuredZip?: string;
  insuredEmail?: string;
  insuredPhone?: string;
  premium?: number;
  coverages: CanonicalCoverage[];
  vehicles: CanonicalVehicle[];
  drivers: CanonicalDriver[];
  endorsements: CanonicalEndorsement[];
  discounts: CanonicalDiscount[];
  claims: CanonicalClaim[];
  parseConfidence: number; // 0-1
  parsedAt: string; // ISO timestamp
  sourceFileName?: string;
}

/**
 * Current policy baseline (from HawkSoft).
 */
export interface BaselineSnapshot {
  premium?: number;
  coverages: CanonicalCoverage[];
  vehicles: CanonicalVehicle[];
  drivers: CanonicalDriver[];
  endorsements: CanonicalEndorsement[];
  discounts: CanonicalDiscount[];
  claims: CanonicalClaim[];
  propertyContext?: PropertyContext;
  // Policy term dates - used to detect stale baseline
  policyEffectiveDate?: string; // ISO date
  policyExpirationDate?: string; // ISO date
  fetchedAt: string; // ISO timestamp
  fetchSource: 'hawksoft_api' | 'local_cache' | 'prior_term_snapshot';
}

// =============================================================================
// COMPARISON TYPES
// =============================================================================

export type ChangeSeverity = 'material_negative' | 'material_positive' | 'non_material';

export type ChangeCategory =
  | 'premium'
  | 'coverage_limit'
  | 'coverage_removed'
  | 'coverage_added'
  | 'deductible'
  | 'vehicle_removed'
  | 'vehicle_added'
  | 'driver_removed'
  | 'driver_added'
  | 'endorsement'
  | 'endorsement_removed'
  | 'endorsement_added'
  | 'discount'
  | 'discount_removed'
  | 'discount_added'
  | 'claim'
  | 'property'
  | 'other';

/**
 * A single detected change between renewal and baseline.
 */
export interface MaterialChange {
  field: string;
  category: ChangeCategory;
  classification: ChangeSeverity;
  oldValue?: string | number | null;
  newValue?: string | number | null;
  changeAmount?: number;
  changePercent?: number;
  severity: ChangeSeverity;
  description: string;
}

/**
 * Quick display summary for the comparison.
 */
export interface ComparisonSummary {
  premiumDirection: 'increase' | 'decrease' | 'same';
  premiumChangeAmount?: number;
  premiumChangePercent?: number;
  materialNegativeCount: number;
  materialPositiveCount: number;
  nonMaterialCount: number;
  headline: string;
  // Baseline data quality
  baselineStatus?: 'prior_term' | 'current_term' | 'unknown';
  baselineStatusReason?: string;
}

/**
 * Full comparison result.
 */
export interface ComparisonResult {
  recommendation: 'renew_as_is' | 'reshop' | 'needs_review';
  summary: ComparisonSummary;
  materialChanges: MaterialChange[];
  nonMaterialChanges: MaterialChange[];
  confidenceLevel: 'high' | 'medium' | 'low';
  // Baseline data quality indicator
  baselineStatus: 'prior_term' | 'current_term' | 'unknown';
  baselineStatusReason?: string;
}

// =============================================================================
// COMPARISON THRESHOLDS
// =============================================================================

export interface ComparisonThresholds {
  premiumIncreasePercent: number; // Default: 10
  premiumIncreaseAmount: number; // Default: 200
  coverageLimitReductionPercent: number; // Default: 20
  deductibleIncreasePercent: number; // Default: 50
}

export const DEFAULT_COMPARISON_THRESHOLDS: ComparisonThresholds = {
  premiumIncreasePercent: 10,
  premiumIncreaseAmount: 200,
  coverageLimitReductionPercent: 20,
  deductibleIncreasePercent: 50,
};

// =============================================================================
// BATCH / CANDIDATE TYPES
// =============================================================================

export interface BatchProcessingLog {
  timestamp: string;
  message: string;
  level: 'info' | 'warn' | 'error';
}

export interface ExtractedAL3File {
  fileName: string;
  content: string;
  sourceZip?: string;
  nestingDepth: number;
}


// ============================================================================
// FILE: src/lib/al3/constants.ts
// ============================================================================

/**
 * AL3 Constants
 * =============
 * ACORD AL3 group codes, transaction types, field position mappings.
 */

// =============================================================================
// AL3 GROUP CODES (Record Identification - first 4 chars)
// =============================================================================

export const AL3_GROUP_CODES = {
  // Header/Trailer
  MASTER_HEADER: '1MHG', // File header
  TRANSACTION_HEADER: '2TRG', // Transaction header
  MASTER_TRAILER: '3MTG', // Transaction/file trailer

  // Business Records
  BUSINESS_INFO_SEGMENT: '5BIS', // General business info
  BUSINESS_PURPOSE_INFO: '5BPI', // Purpose/transaction info
  COVERAGE: '5CVG', // Coverage record
  VEHICLE: '5VEH', // Vehicle record
  DRIVER: '5DRV', // Driver record
  LOCATION: '5LOC', // Location/address record
  PREMIUM: '5PRM', // Premium record
  REMARK: '5RMK', // Remark/note record
  NAME_ADDRESS: '5NAD', // Name and address
  DEDUCTIBLE: '5DED', // Deductible record
  LIMIT: '5LMT', // Limit record
  ENDORSEMENT: '5END', // Endorsement record
  DISCOUNT: '5DSC', // Discount record
  CLAIM: '5CLM', // Claim record
  MORTGAGE: '5MTG', // Mortgagee record
  FORM: '5FOR', // Form/endorsement schedule record

  // Level 6 records (IVANS-specific)
  COVERAGE_VEHICLE: '6CVA', // Vehicle-level coverage (Progressive, etc.)
  COVERAGE_HOME: '6CVH', // Home coverage (SAFECO)
  VEHICLE_DETAIL: '6PVH', // Vehicle physical details
  DRIVER_DETAIL: '6PDR', // Driver detail record
  COMMUNICATION: '6COM', // Communication record (email, phone)

  // Commercial Auto records
  COMMERCIAL_VEHICLE: '5CAR', // Commercial auto vehicle
  SUPPLEMENTARY_DRIVER: '6SDV', // Supplementary driver (commercial)
} as const;

// =============================================================================
// TRANSACTION TYPE CODES
// =============================================================================

export const TRANSACTION_TYPES = {
  // Renewal types
  RWL: 'RWL', // Renewal
  RWQ: 'RWQ', // Renewal Quote
  RNW: 'RNW', // Renewal (alternate)

  // New business
  NBS: 'NBS', // New Business
  NBQ: 'NBQ', // New Business Quote

  // Endorsements
  END: 'END', // Endorsement
  ENQ: 'ENQ', // Endorsement Quote

  // Cancellation
  CAN: 'CAN', // Cancellation
  XLC: 'XLC', // Cancellation (ACORD)
  XLR: 'XLR', // Cancellation Rescind
  REI: 'REI', // Reinstatement

  // Other
  AUD: 'AUD', // Audit
  INQ: 'INQ', // Inquiry
  PCH: 'PCH', // Policy Change
  COM: 'COM', // Commission Statement
  SYN: 'SYN', // Sync/Download (full policy snapshot)
} as const;

/**
 * Default transaction types that are considered renewals.
 */
export const DEFAULT_RENEWAL_TRANSACTION_TYPES = ['RWL', 'RWQ', 'RNW'];

// =============================================================================
// LINE OF BUSINESS CODES
// =============================================================================

export const LOB_CODES: Record<string, string> = {
  'PA': 'Personal Auto',
  'HO': 'Homeowners',
  'DP': 'Dwelling Fire',
  'CA': 'Commercial Auto',
  'GL': 'General Liability',
  'CP': 'Commercial Property',
  'BOP': 'BOP',
  'WC': 'Workers Comp',
  'UM': 'Umbrella',
  'FL': 'Flood',
  'MC': 'Motorcycle',
  'RV': 'Recreational Vehicle',
  'MH': 'Mobile Home',
  'PL': 'Professional Liability',
  'IM': 'Inland Marine',
  'CMP': 'Commercial Package',
  'RENT': 'Renters',
  // IVANS sub-LOB codes (5-char format from 2TRG positions 24-29)
  'PAUTO': 'Personal Auto',
  'AUTOP': 'Personal Auto',
  'CAUTO': 'Commercial Auto',
  'CAUTOB': 'Commercial Auto',
  'AUTOB': 'Commercial Auto',
  'PHOME': 'Homeowners',
  'HOME': 'Homeowners',
  'AUTO': 'Personal Auto',
  'PFIRE': 'Dwelling Fire',
  'FIRE': 'Dwelling Fire',
  'PFLOOD': 'Flood',
  'FLOOD': 'Flood',
  'PBOAT': 'Watercraft',
  'BOAT': 'Watercraft',
  'FMGBN': 'Umbrella',
};

// =============================================================================
// COVERAGE CODE MAP - Standard coverage codes to canonical types
// =============================================================================

export const COVERAGE_CODE_MAP: Record<string, string> = {
  // Auto coverages
  'BI': 'bodily_injury',
  'BIPD': 'bodily_injury',
  'PD': 'property_damage',
  'COLL': 'collision',
  'COL': 'collision',
  'COMP': 'comprehensive',
  'OTC': 'comprehensive',
  'UM': 'uninsured_motorist',
  'UIM': 'underinsured_motorist',
  'UMBI': 'uninsured_motorist',
  'UMUIMBI': 'uninsured_motorist',
  'UMPD': 'uninsured_motorist_pd',
  'MED': 'medical_payments',
  'MEDPAY': 'medical_payments',
  'PIP': 'personal_injury_protection',
  'RENT': 'rental_reimbursement',
  'TOW': 'towing',
  'ROAD': 'roadside_assistance',
  'GAP': 'gap_coverage',

  // Home/Property coverages
  'DWELL': 'dwelling',
  'DWEL': 'dwelling',
  'COV_A': 'dwelling',
  'COV_B': 'other_structures',
  'COV_C': 'personal_property',
  'COV_D': 'loss_of_use',
  'COV_E': 'personal_liability',
  'COV_F': 'medical_payments_to_others',
  'LIAB': 'personal_liability',
  'PP': 'personal_property',
  'PPERS': 'personal_property',
  'LOU': 'loss_of_use',
  'WTRDM': 'water_damage',
  'ROOF': 'roof_surfaces',
  'LFREE': 'claim_free_discount',

  // Commercial coverages
  'GL': 'general_liability',
  'PREM': 'premises_liability',
  'PROD': 'products_liability',
  'PROF': 'professional_liability',
  'EO': 'errors_omissions',
  'DO': 'directors_officers',
  'EPLI': 'employment_practices',
  'CYBER': 'cyber_liability',
  'CRIME': 'crime',
  'BPP': 'business_personal_property',
  'BI_INCOME': 'business_income',
  'EQUIP': 'equipment_breakdown',

  // IVANS-specific coverage codes
  'CSL': 'combined_single_limit',
  'UMISP': 'uninsured_motorist',
  'MEDPM': 'medical_payments',
  'EDC': 'extended_dwelling',
  'PPREP': 'personal_property_replacement',
  'LAC': 'liability_additional',
  'SEWRB': 'sewer_water_backup',
  'FRAUD': 'identity_fraud',
  'MBRKD': 'equipment_breakdown',
  'BOLAW': 'by_operation_of_law',
  'RFRC': 'roof_replacement_cost',
  'ADDIN': 'additional_insured',
  'OS': 'other_structures',

  // Allstate-specific coverage codes
  'PL': 'personal_liability',
  'BSREI': 'building_structures_extended',
  'TRCYC': 'tropical_cyclone',
  'ESIGN': 'early_signing_discount',
  'RESPY': 'responsible_payment_discount',
  'WELCM': 'welcome_discount',
  'LOYAL': 'loyalty_discount',
  'PROTD': 'protective_devices',
  'ACCT': 'account_discount',
  'ESTAB': 'established_customer',
  'ESMRT': 'esmart_discount',
  'ADDA': 'additional_coverage_a',
  'HODIS': 'homeowner_discount',
  'EPPDS': 'auto_pay_discount',
  'ABS': 'anti_lock_brakes_discount',
  'SDC': 'safe_driver_course_discount',
  'FTBYR': 'first_year_buyer_discount',

  // Openly-specific coverage codes
  'MIN01': 'mine_subsidence',
  'SINK': 'sinkhole',
  'HURRA': 'hurricane_deductible',
  'CLIAB': 'cyber_liability',
  'SRVLN': 'service_line',
  'SEWER': 'sewer_water_backup',
  'EQPBK': 'equipment_breakdown',
  'WHSLS': 'wind_hail',
  'HULL': 'watercraft_hull',

  // Progressive-specific discount codes (stored as coverage records in HawkSoft)
  'AFR': 'accident_free_discount',
  'EFT': 'eft_discount',
  'HON': 'homeowner_discount',
  'MC1': 'multi_car_discount',
  'SMP': 'multi_policy_discount',
  'NP2': 'continuous_insurance_discount',
  'NP3': 'continuous_insurance_discount',
  'NP4': 'continuous_insurance_discount',
  'NP5': 'continuous_insurance_discount',
  'SD3': 'safe_driving_discount',
  'IPP': 'paperless_discount',
  'CFR': 'claim_free_discount',
  'CFD': 'claim_free_discount',
  'PPAYD': 'auto_pay_discount',
  'DMH': 'mobile_home_discount',
  'SNRDR': 'senior_discount',
  'GOODD': 'good_driver_discount',
  'DFEDR': 'defensive_driver_discount',
  'ASSOC': 'association_discount',
  'BUNDL': 'bundle_discount',
  'RDD': 'renewal_discount',
  'DAS': 'direct_auto_discount',
  'ASC': 'auto_sign_discount',
  'PIF': 'paid_in_full_discount',
  'DPP': 'deferred_payment_discount',
  'OOD': 'online_discount',

  // Watercraft-specific coverage codes
  'WATER': 'waterski_liability',
  'EQP01': 'equipment_coverage',
  'POLUT': 'pollution_liability',
  'PE': 'personal_effects',
  'PROPP': 'personal_property',
  'SGLID': 'single_limit',
  'WUI': 'watercraft_uninsured',
  'NAVAR': 'navigation_warranty',
  'NSDED': 'named_storm_deductible',
  'MOT01': 'motor_coverage',
  'TRLR': 'trailer_coverage',

  // Auto-specific codes
  'ACPE': 'accident_personal_effects',
  'LLPP': 'loan_lease_payoff',
};

/**
 * Coverage types that are really discounts/credits.
 * Used to partition discounts from real coverages in snapshot/baseline builders.
 */
export const DISCOUNT_COVERAGE_TYPES = new Set([
  'accident_free_discount',
  'eft_discount',
  'homeowner_discount',
  'multi_car_discount',
  'multi_policy_discount',
  'continuous_insurance_discount',
  'safe_driving_discount',
  'paperless_discount',
  'early_signing_discount',
  'responsible_payment_discount',
  'welcome_discount',
  'loyalty_discount',
  'protective_devices',
  'account_discount',
  'established_customer',
  'esmart_discount',
  'claim_free_discount',
  'auto_pay_discount',
  'mobile_home_discount',
  'senior_discount',
  'good_driver_discount',
  'defensive_driver_discount',
  'association_discount',
  'bundle_discount',
  'renewal_discount',
  'direct_auto_discount',
  'auto_sign_discount',
  'paid_in_full_discount',
  'deferred_payment_discount',
  'online_discount',
  'anti_lock_brakes_discount',
  'safe_driver_course_discount',
  'first_year_buyer_discount',
]);

/**
 * Coverage types that are vehicle-specific and should NOT be flattened to policy level.
 * These coverages can have different limits/deductibles per vehicle.
 */
export const VEHICLE_LEVEL_COVERAGE_TYPES = new Set([
  'comprehensive',
  'collision',
  'towing',               // Towing/Roadside (canonical)
  'rental_reimbursement', // Rental Reimbursement (canonical)
  'glass',                // Glass Coverage
  'gap_coverage',         // GAP Insurance (canonical)
  'loan_lease_payoff',    // Loan/Lease Payoff (canonical)
  'full_glass',           // Full Glass Coverage
  'roadside_assistance',  // Roadside Assistance (canonical)
]);

// =============================================================================
// FIELD POSITION MAPPINGS (for fixed-width AL3 parsing)
// =============================================================================

/**
 * Transaction header (2TRG) field positions.
 * Positions are for the IVANS/ACORD AL3 fixed-width record format (212 bytes):
 *   0-3:   group code (2TRG)
 *   4-6:   record length (212)
 *   7:     separator
 *   8:     version (4 or 7)
 *   167-169: transaction type (RWL, PCH, COM, etc.)
 *   196-203: processing date (YYYYMMDD)
 *   204-211: effective date (YYYYMMDD)
 */
export const TRG_FIELDS = {
  TRANSACTION_TYPE: { start: 167, end: 170 }, // 3 chars (RWL, RWQ, PCH, COM, NBS, etc.)
  COMPANY_NAME: { start: 47, end: 80 }, // ~33 chars (carrier company name)
  COMPANY_CODE: { start: 10, end: 12 }, // 2 chars (carrier code fragment)
  POLICY_NUMBER: { start: 12, end: 37 }, // Not reliably in 2TRG — extracted from 5BPI
  EFFECTIVE_DATE: { start: 204, end: 212 }, // 8 chars (YYYYMMDD)
  EXPIRATION_DATE: { start: 196, end: 204 }, // 8 chars — actually processing/batch date
  LOB_CODE: { start: 24, end: 30 }, // 6 chars (PHOME, PAUTO, CAUTO, etc.) — includes leading space
  INSURED_NAME: { start: 56, end: 96 }, // Not reliably in 2TRG — extracted from 5BIS
} as const;

/**
 * Coverage (5CVG) field positions.
 * IVANS format: 629-byte records. Data starts at position 30 after reference header.
 *   5CVG629 7 F200025BPIF10001    CSL            0000100000
 *                                 ^30            ^45
 */
export const CVG_FIELDS = {
  COVERAGE_CODE: { start: 30, end: 45 }, // 15 chars (CSL, UMISP, MEDPM, etc.)
  DESCRIPTION: { start: 30, end: 45 }, // Same as code in IVANS format
  LIMIT: { start: 45, end: 56 }, // 11 chars (amount)
  DEDUCTIBLE: { start: 65, end: 76 }, // 11 chars (second amount / split limit)
  PREMIUM: { start: 56, end: 65 }, // 9 chars (rare in 5CVG — premiums are in 6CVA)
} as const;

/**
 * Vehicle-level coverage (6CVA) field positions.
 * IVANS format: 281-byte records. Contains per-vehicle coverage premiums and limits.
 *   6CVA281 B W100085VEHR10001    CSL                           00000022100+              00300000
 *                                 ^30                           ^60         ^72           ^90
 */
export const CVA_FIELDS = {
  COVERAGE_CODE: { start: 30, end: 45 }, // 15 chars (includes filler before code)
  PREMIUM: { start: 60, end: 72 }, // 12 chars (amount with +/- sign, implied 2 decimals)
  LIMIT: { start: 103, end: 113 }, // 10 chars (split limit part 1: per-person, ref 103-112)
  LIMIT_2: { start: 113, end: 118 }, // 5 chars (split limit part 2: per-accident suffix)
  DEDUCTIBLE: { start: 118, end: 125 }, // 7 chars (deductible amount, 6 digits zero-padded)
  DESCRIPTION: { start: 145, end: 195 }, // 50 chars (human-readable coverage name)
} as const;

/**
 * Home coverage (6CVH) field positions.
 * IVANS/SAFECO format: 240-byte records.
 *   6CVH240   W110016HRUR10001    DWELL                         00000187600               002620000100000100
 *                                 ^30                           ^60                       ^90
 */
export const CVH_FIELDS = {
  COVERAGE_CODE: { start: 30, end: 45 }, // 15 chars
  LIMIT: { start: 60, end: 72 }, // 12 chars (primary limit, e.g., dwelling amount)
  SECONDARY_AMOUNT: { start: 90, end: 101 }, // 11 chars (secondary limit or amount)
} as const;

/**
 * Vehicle (5VEH) field positions.
 * IVANS format: 270-byte records.
 *   5VEH270 C R100015LAGL10001    0001????2010DODGE               CHALLENGER          ?????VIN17CHARS12345
 *                                 ^30  ^34  ^38  ^42                ^62                 ^82  ^87
 */
export const VEH_FIELDS = {
  SEQUENCE: { start: 30, end: 34 }, // 4 chars (vehicle number)
  YEAR: { start: 38, end: 42 }, // 4 chars
  MAKE: { start: 42, end: 62 }, // 20 chars
  MODEL: { start: 62, end: 82 }, // 20 chars
  VIN: { start: 87, end: 104 }, // 17 chars
  USAGE: { start: 82, end: 87 }, // 5 chars (between model and VIN)
} as const;

/**
 * Driver (5DRV) field positions.
 * IVANS format: 223-byte records.
 *   5DRV223 B F200015BPIF10001    ????0001P        Tanaye                     Walker - Heard          ?????????7776577                  AL??????890709F
 *                                 ^30  ^34  ^38^39 ^47 (first)                ^74 (last)              ^98      ^107                     ^132    ^140   ^146
 */
export const DRV_FIELDS = {
  NAME: { start: 39, end: 98 }, // 59 chars: first name (39-73, 35 chars) + last name (74-97, 24 chars)
  DOB: { start: 140, end: 146 }, // 6 chars (YYMMDD format, e.g., 890709)
  DOB_FULL: { start: 160, end: 168 }, // 8 chars (YYYYMMDD format, e.g., 19890709)
  LICENSE_NUMBER: { start: 102, end: 115 }, // 13 chars (may have masked prefix)
  LICENSE_STATE: { start: 132, end: 134 }, // 2 chars (e.g., AL)
  GENDER: { start: 146, end: 147 }, // 1 char (F/M)
} as const;

/**
 * Discount (5DSC) field positions.
 * Data starts at position 30 in IVANS format.
 */
export const DSC_FIELDS = {
  DISCOUNT_CODE: { start: 30, end: 45 }, // 15 chars
  DESCRIPTION: { start: 45, end: 85 }, // 40 chars
  AMOUNT: { start: 85, end: 96 }, // 11 chars
  PERCENT: { start: 96, end: 106 }, // 10 chars
} as const;

/**
 * Claim (5CLM) field positions.
 * Data starts at position 30 in IVANS format.
 */
export const CLM_FIELDS = {
  CLAIM_NUMBER: { start: 30, end: 50 }, // 20 chars
  CLAIM_DATE: { start: 50, end: 58 }, // 8 chars (YYYYMMDD)
  CLAIM_TYPE: { start: 58, end: 78 }, // 20 chars
  AMOUNT: { start: 78, end: 89 }, // 11 chars
  STATUS: { start: 89, end: 99 }, // 10 chars
} as const;

/**
 * Endorsement (5END) field positions.
 * Data starts at position 30 in IVANS format.
 */
export const END_FIELDS = {
  ENDORSEMENT_CODE: { start: 30, end: 45 }, // 15 chars
  DESCRIPTION: { start: 45, end: 85 }, // 40 chars
  EFFECTIVE_DATE: { start: 85, end: 93 }, // 8 chars (YYYYMMDD)
  PREMIUM: { start: 93, end: 104 }, // 11 chars
} as const;

/**
 * Form/Endorsement schedule (5FOR) field positions.
 * IVANS format: 203-byte records.
 *   5FOR203 5 F200015BPIF10001    001A206 AL   ??description??   date
 *                                 ^30   ^34    ^40               ^90
 */
export const FOR_FIELDS = {
  FORM_NUMBER: { start: 30, end: 40 }, // 10 chars (form number + state)
  DESCRIPTION: { start: 40, end: 90 }, // 50 chars
  EFFECTIVE_DATE: { start: 90, end: 96 }, // 6 chars (YYMMDD)
} as const;

// =============================================================================
// NEW FIELD POSITION MAPPINGS (from AL3 reference guide)
// =============================================================================

/**
 * Basic Insured Segment (5BIS) field positions.
 * IVANS format: 172-byte records.
 */
export const BIS_FIELDS = {
  ENTITY_TYPE: { start: 30, end: 31 }, // 1 char (P=Person, C=Company, G=Group)
  PREFIX: { start: 31, end: 39 }, // 8 chars (name prefix/title, usually spaces)
  FIRST_NAME: { start: 39, end: 67 }, // 28 chars (verified from Progressive hex dump)
  LAST_NAME: { start: 67, end: 90 }, // 23 chars (verified from Progressive hex dump)
  SUFFIX: { start: 90, end: 92 }, // 2 chars
} as const;

/**
 * Insured Address Continuation (9BIS) field positions.
 * IVANS format: 168-343 bytes.
 */
export const BIS_ADDRESS_FIELDS = {
  ADDRESS_1: { start: 29, end: 59 }, // 30 chars
  ADDRESS_2: { start: 59, end: 89 }, // 30 chars
  CITY: { start: 89, end: 109 }, // 20 chars (may have leading ?)
  STATE: { start: 109, end: 111 }, // 2 chars
  ZIP: { start: 111, end: 116 }, // 5 chars
  ZIP4: { start: 116, end: 120 }, // 4 chars
  PHONE: { start: 120, end: 130 }, // 10 chars
} as const;

/**
 * Safeco shorter 9BIS variant (168-byte version).
 */
export const BIS_ADDRESS_FIELDS_SHORT = {
  ADDRESS_1: { start: 29, end: 59 }, // 30 chars
  CITY: { start: 59, end: 79 }, // 20 chars
  STATE: { start: 79, end: 81 }, // 2 chars
  ZIP: { start: 81, end: 91 }, // 10 chars (ZIP+4)
  PHONE: { start: 91, end: 101 }, // 10 chars
} as const;

/**
 * Basic Policy Information (5BPI) field positions.
 * IVANS format: 282-511 bytes.
 */
export const BPI_FIELDS = {
  POLICY_NUMBER: { start: 24, end: 49 }, // 25 chars
  NAIC_CODE: { start: 59, end: 64 }, // 5 chars
  LOB_CODE: { start: 64, end: 69 }, // 5 chars
  EFF_DATE_SHORT: { start: 73, end: 79 }, // 6 chars (YYMMDD)
  EXP_DATE_SHORT: { start: 79, end: 85 }, // 6 chars (YYMMDD)
  WRITTEN_PREMIUM: { start: 98, end: 109 }, // 11 chars (implied 2 decimals)
  ANNUAL_PREMIUM: { start: 109, end: 120 }, // 11 chars (with +/- sign)
} as const;

/**
 * Location Address Group (5LAG) field positions.
 * IVANS format: 199-636 bytes.
 */
export const LAG_FIELDS = {
  LOCATION_NUMBER: { start: 24, end: 28 }, // 4 chars
  ADDRESS: { start: 28, end: 58 }, // 30 chars
  ADDRESS_2: { start: 58, end: 88 }, // 30 chars
  CITY: { start: 88, end: 108 }, // 20 chars
  STATE: { start: 108, end: 110 }, // 2 chars
  ZIP: { start: 110, end: 115 }, // 5 chars
  COUNTY: { start: 121, end: 136 }, // 15 chars
} as const;

/**
 * Additional Other Insured / Mortgagee (5AOI) field positions.
 * IVANS format: 186-238 bytes.
 */
export const AOI_FIELDS = {
  SEQUENCE: { start: 24, end: 27 }, // 3 chars
  INTEREST_TYPE: { start: 27, end: 29 }, // 2 chars (LH=Lienholder, MS=Mortgagee, CN=Co-Named)
  ENTITY_TYPE: { start: 31, end: 32 }, // 1 char (C=Company, P=Person)
  NAME: { start: 32, end: 72 }, // 40 chars
  LOAN_NUMBER: { start: 131, end: 141 }, // 10 chars
} as const;

/**
 * Communication record (6COM) field positions.
 * IVANS format: 416 bytes.
 */
export const COM_FIELDS = {
  COMM_TYPE: { start: 24, end: 29 }, // 5 chars (EMAIL, PHONE, CELL)
  VALUE: { start: 29, end: 99 }, // 70 chars
} as const;

/**
 * Remark record (5RMK) field positions.
 * IVANS format: 195 bytes.
 */
export const RMK_FIELDS = {
  SEQUENCE: { start: 28, end: 30 }, // 2 chars
  REMARK_TYPE: { start: 30, end: 31 }, // 1 char (N=Normal)
  TEXT: { start: 31, end: 195 }, // 164 chars
} as const;

/**
 * Insured Supplemental Info (5ISI) field positions.
 * IVANS format: 147-203 bytes.
 */
export const ISI_FIELDS = {
  DOB_SHORT: { start: 24, end: 30 }, // 6 chars (YYMMDD)
  GENDER: { start: 32, end: 33 }, // 1 char (M/F)
  SPOUSE_DOB_SHORT: { start: 35, end: 41 }, // 6 chars (YYMMDD)
  HOMEOWNER_FLAG: { start: 80, end: 81 }, // 1 char (Y/N)
  DOB_FULL: { start: 97, end: 105 }, // 8 chars (YYYYMMDD)
  SPOUSE_DOB_FULL: { start: 105, end: 113 }, // 8 chars (YYYYMMDD)
} as const;


// ============================================================================
// FILE: src/lib/al3/parser.ts
// ============================================================================

/**
 * AL3 Parser
 * ==========
 * Parses ACORD AL3 flat files into structured transaction data.
 * Three-tier strategy:
 *   1. Regex extraction for common fields
 *   2. Position-based for AL3 standard fields
 *   3. Carrier-specific overrides from carrierProfiles
 */

import type {
  AL3ParsedTransaction,
  AL3TransactionHeader,
  AL3Coverage,
  AL3Vehicle,
  AL3Driver,
  AL3Location,
  AL3Discount,
  AL3Claim,
  AL3Endorsement,
  AL3Mortgagee,
} from '@/types/renewal.types';
import {
  AL3_GROUP_CODES,
  TRG_FIELDS,
  CVG_FIELDS,
  CVA_FIELDS,
  CVH_FIELDS,
  VEH_FIELDS,
  DRV_FIELDS,
  DSC_FIELDS,
  CLM_FIELDS,
  END_FIELDS,
  FOR_FIELDS,
  BIS_FIELDS,
  BIS_ADDRESS_FIELDS,
  BIS_ADDRESS_FIELDS_SHORT,
  BPI_FIELDS,
  LAG_FIELDS,
  AOI_FIELDS,
  COM_FIELDS,
  RMK_FIELDS,
  LOB_CODES,
  COVERAGE_CODE_MAP,
  DISCOUNT_COVERAGE_TYPES,
} from './constants';

// =============================================================================
// HELPERS
// =============================================================================

/**
 * Parse an AL3 date string (YYYYMMDD) to ISO string.
 */
export function parseAL3Date(dateStr: string): string | undefined {
  const trimmed = dateStr.trim();
  if (!trimmed || trimmed.length < 8 || trimmed === '00000000') return undefined;

  const year = trimmed.substring(0, 4);
  const month = trimmed.substring(4, 6);
  const day = trimmed.substring(6, 8);

  const parsed = new Date(`${year}-${month}-${day}`);
  if (isNaN(parsed.getTime())) return undefined;

  return `${year}-${month}-${day}`;
}

/**
 * Parse an AL3 numeric field, trimming whitespace and removing non-numeric chars.
 */
export function parseAL3Number(str: string): number | undefined {
  const trimmed = str.trim().replace(/[^0-9.-]/g, '');
  if (!trimmed) return undefined;
  const num = parseFloat(trimmed);
  return isNaN(num) ? undefined : num;
}

/**
 * Parse a limit string that may contain split limits (e.g., "250,000/500,000"
 * for per-person/per-accident, or "50/1,500" for per-day/per-occurrence).
 * Returns the numeric value of the first (per-person) part only to enable
 * consistent comparison between HawkSoft and AL3 data.
 */
export function parseSplitLimit(str: string): number | undefined {
  if (!str) return undefined;
  const trimmed = str.trim();
  // Split on "/" and take the first part
  const firstPart = trimmed.split('/')[0];
  const cleaned = firstPart.replace(/[^0-9.-]/g, '');
  if (!cleaned) return undefined;
  const num = parseFloat(cleaned);
  return isNaN(num) ? undefined : num;
}

// =============================================================================
// UNIVERSAL PATTERN EXTRACTION
// =============================================================================

/**
 * Pattern definitions for universal data extraction.
 * These patterns identify data types regardless of field position.
 */
const EXTRACTION_PATTERNS = {
  // Numeric patterns
  LIMIT_8DIGIT: /\b(\d{8})\b/g,              // 8-digit zero-padded limit (e.g., 00300000)
  LIMIT_7DIGIT: /\b(0\d{6})\b/g,             // 7-digit with leading zero
  DEDUCTIBLE: /\b(\d{4,7})\b/g,              // 4-7 digit deductibles
  PREMIUM_SIGNED: /(\d{8,12}[+-])/g,         // Premium with trailing sign (cents)
  PREMIUM_PLAIN: /\b(\d{6,10})\b/g,          // Plain premium amount

  // Date patterns
  DATE_YYYYMMDD: /\b(20[2-3]\d[01]\d[0-3]\d)\b/g,  // 2020-2039 dates

  // Identifier patterns
  VIN: /\b([A-HJ-NPR-Z0-9]{17})\b/g,         // 17-char VIN (no I, O, Q)
  POLICY_NUMBER: /\b([A-Z0-9]{6,15})\b/g,    // Policy number patterns
  COVERAGE_CODE: /\b([A-Z]{2,6}[0-9]{0,2})\b/g,  // Coverage codes like BI, PD, COMP, MIN01

  // Text patterns
  DESCRIPTION: /([A-Z][a-z]+(?:\s+[A-Za-z]+)*)/g,  // Title case descriptions
  NAME: /([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)/g,       // Full names (First Last)
};

/**
 * Extract all matches of a pattern from text after a given start position.
 */
function extractPatternMatches(
  text: string,
  pattern: RegExp,
  startPos: number = 0
): Array<{ value: string; position: number }> {
  const results: Array<{ value: string; position: number }> = [];
  const section = text.substring(startPos);
  const regex = new RegExp(pattern.source, pattern.flags);
  let match;
  while ((match = regex.exec(section)) !== null) {
    results.push({
      value: match[1] || match[0],
      position: startPos + match.index,
    });
  }
  return results;
}

/**
 * Universal coverage data extractor.
 * Tries fixed positions first, falls back to pattern matching.
 */
interface ExtractedCoverageData {
  code?: string;
  description?: string;
  limitAmount?: number;
  limitStr?: string;
  deductibleAmount?: number;
  deductibleStr?: string;
  premium?: number;
}

function extractCoverageDataUniversal(
  line: string,
  codeStartPos: number = 30,
  codeEndPos: number = 45
): ExtractedCoverageData {
  const result: ExtractedCoverageData = {};

  // 1. Coverage code - usually reliable at fixed position
  const codeSection = line.substring(codeStartPos, codeEndPos).trim();
  const codeMatch = codeSection.match(/^([A-Z0-9_]+)/);
  result.code = codeMatch ? codeMatch[1] : undefined;

  // 2. Extract data from the remainder of the line (after code position)
  const dataSection = line.substring(codeEndPos);

  // 3. Find limit - look for 8-digit zero-padded numbers
  const eightDigitMatches = extractPatternMatches(dataSection, /(\d{8})/g, 0);
  if (eightDigitMatches.length > 0) {
    const rawLimit = eightDigitMatches[0].value;
    const parsed = parseInt(rawLimit.replace(/^0+/, '') || '0', 10);
    if (parsed > 0) {
      result.limitAmount = parsed;
      result.limitStr = String(parsed);
    }

    // Check for deductible immediately after limit
    const limitEndPos = eightDigitMatches[0].position + 8;
    const afterLimit = dataSection.substring(limitEndPos, limitEndPos + 10);
    const dedMatch = afterLimit.match(/^(\d{4,7})/);
    if (dedMatch) {
      const parsedDed = parseInt(dedMatch[1].replace(/^0+/, '') || '0', 10);
      if (parsedDed > 0 && parsedDed <= 25000) {
        result.deductibleAmount = parsedDed;
        result.deductibleStr = String(parsedDed);
      }
    }
  }

  // 4. Find premium - look for signed amounts (digits + +/-)
  const premiumMatches = extractPatternMatches(dataSection, /(\d{6,12})[+-]/g, 0);
  if (premiumMatches.length > 0) {
    const rawPremium = premiumMatches[0].value;
    const parsed = parseInt(rawPremium, 10);
    if (parsed > 0) {
      result.premium = parsed / 100; // AL3 premiums are in cents
    }
  }

  // 5. Find description - look for title case text at end of line
  const descMatches = extractPatternMatches(line.substring(100), /([A-Z][a-zA-Z]+(?:\s*[A-Za-z]+)*)/g, 0);
  if (descMatches.length > 0) {
    // Use the longest match as the description
    const longest = descMatches.reduce((a, b) => a.value.length > b.value.length ? a : b);
    if (longest.value.length > 3) {
      result.description = longest.value.trim();
    }
  }

  return result;
}

// =============================================================================
// FIELD EXTRACTION
// =============================================================================

/**
 * Extract a fixed-width field from a line.
 * Truncates at field separators (EDIFACT control chars) used by some carriers.
 */
function extractField(line: string, pos: { start: number; end: number }): string {
  const raw = line.substring(pos.start, pos.end) || '';
  // Truncate at the first EDIFACT field separator (0xFA-0xFF range or control chars < 0x20 except space)
  // These separators indicate field boundaries in SAFECO/Universal format variants
  let end = raw.length;
  for (let i = 0; i < raw.length; i++) {
    const c = raw.charCodeAt(i);
    if ((c >= 0xFA && c <= 0xFF) || (c < 0x20 && c !== 0x20)) {
      end = i;
      break;
    }
  }
  return raw.substring(0, end).trim();
}

/**
 * Check if a record line uses EDIFACT-style 0xFA field separators (Allstate format).
 * Only checks after position 28 (past the standard AL3 header area).
 */
function isEDIFACTFormat(line: string): boolean {
  for (let i = 28; i < line.length; i++) {
    if (line.charCodeAt(i) === 0xFA) return true;
  }
  return false;
}

/**
 * Parse EDIFACT-style segments from a record line split on 0xFA bytes.
 * Allstate format: after each 0xFA, segments have a 2-char hex tag, optional space, then data.
 * Segments may contain embedded sub-records (e.g., multiple 6CVH records packed together).
 * Truncates segment data at embedded record boundaries.
 * Returns an array of { tag, data } where:
 *   - First segment (before first 0xFA) is tagged 'REF'
 *   - Subsequent segments: strip 2-char hex tag + optional space, clean non-printable/filler chars
 */
function parseEDIFACTSegments(line: string): { tag: string; data: string }[] {
  const segments: { tag: string; data: string }[] = [];
  // Split on 0xFA
  const parts: string[] = [];
  let start = 0;
  for (let i = 0; i < line.length; i++) {
    if (line.charCodeAt(i) === 0xFA) {
      parts.push(line.substring(start, i));
      start = i + 1;
    }
  }
  parts.push(line.substring(start));

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    if (i === 0) {
      // First segment is the header/reference area — clean and tag as REF
      const cleaned = part.replace(/[\x00-\x1F\x7F-\xFF]/g, '').trim();
      segments.push({ tag: 'REF', data: cleaned });
    } else {
      // Clean non-printable chars
      let data = part.replace(/[\x00-\x1F\x7F-\xFF]/g, '');

      // Truncate at embedded record boundaries: "?<digit><3 uppercase><3 digits>"
      // When found, extract the embedded header as a separate SUB segment so it isn't lost.
      // E.g., "71?6CVH292 8 W100016HRUR10001    DWELL" → truncate to "71", push "6CVH292..." as SUB
      const boundaryMatch = data.match(/\?\d[A-Z]{3}\d{3}/);
      if (boundaryMatch && boundaryMatch.index !== undefined) {
        const embeddedHeader = data.substring(boundaryMatch.index + 1); // skip the "?"
        data = data.substring(0, boundaryMatch.index);
        // Push the embedded header as a SUB if it looks like a record header
        if (/^\d[A-Z]{3}\d{3}/.test(embeddedHeader)) {
          // Process current data first (below), then add the SUB
          const currentTagMatch = data.match(/^([0-9A-Fa-f]{2})\s?(.*)/);
          let currentTag = '';
          let currentData = data;
          if (currentTagMatch) {
            currentTag = currentTagMatch[1].toUpperCase();
            currentData = currentTagMatch[2].replace(/\?+/g, '').trim();
          }
          if (currentData) {
            segments.push({ tag: currentTag, data: currentData });
          }
          segments.push({ tag: 'SUB', data: embeddedHeader });
          continue;
        }
      }

      // Check if the FULL data (before hex tag strip) is an embedded sub-record header.
      // Headers like "6CVH292..." or "6FRU144..." start with chars that look like hex tags
      // (e.g., "6C", "6F") — must detect them BEFORE stripping, or the header is destroyed.
      if (/^\d[A-Z]{3}\d{3}/.test(data)) {
        segments.push({ tag: 'SUB', data });
        continue;
      }

      // Strip 2-char hex tag at start (e.g., "0E ", "08 ", "1E ")
      const tagMatch = data.match(/^([0-9A-Fa-f]{2})\s?(.*)/);
      let tag = '';
      if (tagMatch) {
        tag = tagMatch[1].toUpperCase();
        data = tagMatch[2];
      }

      // Check if the remaining data IS an embedded record header (after tag strip)
      if (/^\d[A-Z]{3}\d{3}/.test(data)) {
        // Mark as embedded sub-record header (used by parseEDIFACTSubRecords)
        segments.push({ tag: 'SUB', data });
        continue;
      }

      // Clean filler characters (? runs)
      data = data.replace(/\?+/g, '').trim();

      if (data) {
        segments.push({ tag, data });
      }
    }
  }

  return segments;
}

/**
 * Parse multiple EDIFACT sub-records from a single record line.
 * Allstate packs multiple records into one line separated by group code patterns in segments.
 * Returns array of { groupCode, coverageCode, segments } for each sub-record found.
 */
function parseEDIFACTSubRecords(line: string): { groupCode: string; coverageCode: string; segments: { tag: string; data: string }[] }[] {
  const allSegments = parseEDIFACTSegments(line);
  const subRecords: { groupCode: string; coverageCode: string; segments: { tag: string; data: string }[] }[] = [];

  // The REF segment contains the first record's group code and coverage code
  // Pattern: "6CVH292 8 W100026HRUR10001    MEDPM"
  // After that, segments may contain new record headers in their data
  let currentGroupCode = '';
  let currentCoverageCode = '';
  let currentSegments: { tag: string; data: string }[] = [];

  for (const seg of allSegments) {
    if (seg.tag === 'REF' || seg.tag === 'SUB') {
      // Extract group code and coverage code from REF or SUB (embedded sub-record) header
      // Pattern: "6CVH292 8 W100026HRUR10001    MEDPM"
      const headerMatch = seg.data.match(/^(\d[A-Z]{3})\d{3}\s.*?\s{2,}(\S+)\s*$/);
      if (headerMatch) {
        // Save previous sub-record if it has data
        if (currentGroupCode && (currentSegments.length > 0 || seg.tag === 'SUB')) {
          if (currentSegments.length > 0) {
            subRecords.push({ groupCode: currentGroupCode, coverageCode: currentCoverageCode, segments: currentSegments });
          }
        }
        currentGroupCode = headerMatch[1];
        currentCoverageCode = headerMatch[2];
        currentSegments = [];
      }
      continue;
    }

    currentSegments.push(seg);
  }

  // Save last sub-record
  if (currentGroupCode && currentSegments.length > 0) {
    subRecords.push({ groupCode: currentGroupCode, coverageCode: currentCoverageCode, segments: currentSegments });
  }

  return subRecords;
}

/**
 * Parse Allstate premium format: digits with trailing +/- sign, value in cents.
 * E.g., "0272689+" → 2726.89, "0005000-" → -50.00
 */
function parseAllstatePremium(str: string): number | undefined {
  const match = str.match(/^0*(\d+)([+-])?$/);
  if (!match) return undefined;
  const cents = parseInt(match[1], 10);
  if (isNaN(cents) || cents === 0) return undefined;
  const value = cents / 100;
  return match[2] === '-' ? -value : value;
}

/**
 * Parse all EDIFACT-format coverages from a 6CVH or 6CVA record line.
 * Allstate packs multiple coverage sub-records into a single line.
 * Each sub-record has: coverage code in header, premium (digits+sign), limit (long digits), description (text).
 */
function parseEDIFACTHomeCoverages(line: string): AL3Coverage[] {
  const subRecords = parseEDIFACTSubRecords(line);
  const results: AL3Coverage[] = [];

  for (const sub of subRecords) {
    // Only process coverage records (6CVH, 6CVA), skip other embedded record types
    if (sub.groupCode !== '6CVH' && sub.groupCode !== '6CVA') continue;
    const code = sub.coverageCode;
    if (!code) continue;

    // Skip sub-records that contain embedded transaction data (2TRG/2TCG/5BIS headers
    // leaked into coverage segments). These produce garbage coverages like "ACCT" with
    // descriptions that are insured names.
    const hasEmbeddedTxData = sub.segments.some(s =>
      /2TRG\d{3}/.test(s.data) || /2TCG\d{3}/.test(s.data) ||
      /5BIS\d{3}/.test(s.data)
    );
    if (hasEmbeddedTxData) continue;

    let premium: number | undefined;
    let limitAmount: number | undefined;
    let limitStr: string | undefined;
    let deductibleAmount: number | undefined;
    let deductibleStr: string | undefined;
    let description: string | undefined;

    for (const seg of sub.segments) {
      const d = seg.data;
      const t = seg.tag.toUpperCase();

      // Premium: digits with trailing +/- (Allstate cents format)
      if (premium === undefined && /^\d{4,}[+-]$/.test(d)) {
        premium = parseAllstatePremium(d);
        continue;
      }

      // Limit: tag "1E" with digit-only data (leading zeros, e.g., "00025000")
      // Standard format: 8 zero-padded digits. Compound: >8 digits = limit(8) + extra.
      // Short values (<8 digits) occur when records are truncated at field boundaries —
      // right-pad with zeros to 8 digits (e.g., "0065" → "00650000" → 650,000).
      if (limitAmount === undefined && t === '1E' && /^0{1,}\d+$/.test(d) && d.length >= 3) {
        let limitPortion = d;
        if (limitPortion.length > 8) {
          limitPortion = limitPortion.substring(0, 8);
        } else if (limitPortion.length < 8) {
          limitPortion = limitPortion.padEnd(8, '0');
        }
        const cleaned = limitPortion.replace(/^0+/, '') || '0';
        limitAmount = parseInt(cleaned, 10);
        limitStr = limitPortion;
        continue;
      }

      // Fallback limit: any segment with leading-zero digits if tag 1E wasn't found
      if (limitAmount === undefined && /^0{2,}\d{4,}$/.test(d) && d.length <= 10) {
        const cleaned = d.replace(/^0+/, '') || '0';
        limitAmount = parseInt(cleaned, 10);
        limitStr = d;
        continue;
      }

      // Deductible: shorter numeric segment after limit is found
      if (deductibleAmount === undefined && limitAmount !== undefined && /^\d{4,8}$/.test(d)) {
        const val = parseInt(d, 10);
        if (val > 0 && val !== limitAmount) {
          deductibleAmount = val;
          deductibleStr = d;
        }
        continue;
      }

      // Description: text with 3+ alpha chars, prefer lowercase text (human-readable)
      // Skip embedded transaction references (e.g., "3P PHOME FMGBN0 PL DOWN   ALLSTATE")
      if (!description && /[a-zA-Z]{3,}/.test(d) && !/^\d+[+-]?$/.test(d) && !/^0{2,}\d/.test(d)) {
        if (/^[0-9][A-Z]\s/.test(d)) continue; // Embedded reference (e.g., "3P PHOME...")
        if (/^[A-Z]\d{5,}/.test(d)) continue; // Policy/reference number
        if (/[a-z]/.test(d) || d.length > 5) {
          description = d;
        }
        continue;
      }
    }

    results.push({
      code,
      description: description || code,
      limit: limitStr || undefined,
      limitAmount,
      deductible: deductibleStr || undefined,
      deductibleAmount,
      premium,
    });
  }

  return results;
}

/**
 * Identify the group code of an AL3 record line.
 */
function getGroupCode(line: string): string {
  return line.substring(0, 4);
}

// =============================================================================
// RECORD SPLITTING
// =============================================================================

/**
 * Known AL3 group code prefixes (first character indicates record level).
 * Used to detect record boundaries in concatenated (no-newline) AL3 streams.
 */
const KNOWN_GROUP_CODE_PATTERN = /^[0-9][A-Z]{3}/;

/**
 * Split a concatenated AL3 stream into individual record lines.
 *
 * IVANS AL3 files use fixed-width records. Each record starts with a 4-char
 * group code (e.g. 1MHG, 2TRG, 5BIS) followed by a 3-char record length.
 * Records may be concatenated without newlines. This function detects that
 * case and splits by walking the length fields.
 */
export function splitAL3Records(content: string): string[] {
  // First try normal line splitting
  const lines = content.split(/\r?\n/).filter((l) => l.length >= 4);

  // If we got multiple lines, the file has normal line breaks
  if (lines.length > 1) {
    return lines;
  }

  // Single line — likely concatenated fixed-width records.
  // Walk through using the record length field (chars 4-7, 3 digits).
  const raw = lines[0] || content;
  if (raw.length < 7) return lines;

  const records: string[] = [];
  let pos = 0;

  while (pos < raw.length) {
    // Need at least 7 chars for group code (4) + length (3)
    if (pos + 7 > raw.length) {
      break;
    }

    const groupCode = raw.substring(pos, pos + 4);

    // Verify this looks like a valid group code
    if (!KNOWN_GROUP_CODE_PATTERN.test(groupCode)) {
      pos++;
      continue;
    }

    const lengthStr = raw.substring(pos + 4, pos + 7).trim();
    const recordLength = parseInt(lengthStr, 10);

    if (isNaN(recordLength) || recordLength < 7 || recordLength > 1000) {
      // Invalid length — skip this match and keep scanning
      pos++;
      continue;
    }

    // Extract the record
    const record = raw.substring(pos, pos + recordLength);
    records.push(record);

    // Some carriers (e.g., Universal/SAFECO) embed sub-records within container records
    // like 1MHG or 2TCG. Scan the container content for embedded records, but extract
    // from the FULL raw stream to get complete records even if they overflow the container.
    if (groupCode === '1MHG' || groupCode === '2TCG' || groupCode === '9BIS') {
      extractEmbeddedRecords(raw, pos, recordLength, records);
    }

    pos += recordLength;
  }

  return records.length > 0 ? records : lines;
}

/**
 * Scan a container record for embedded sub-records.
 * Some carriers embed 2TRG, 5BIS, 5BPI etc. inside 1MHG or 2TCG records.
 * Embedded records may overflow the container boundary — we extract from the
 * full raw stream to get the complete record.
 */
function extractEmbeddedRecords(
  raw: string,
  containerStart: number,
  containerLength: number,
  records: string[]
): void {
  const embeddedCodes = ['2TRG', '5BIS', '5BPI'];
  const searchEnd = containerStart + containerLength;

  for (const code of embeddedCodes) {
    let searchPos = containerStart + 8; // Skip the container's own header
    while (searchPos < searchEnd - 4) {
      const idx = raw.indexOf(code, searchPos);
      if (idx === -1 || idx >= searchEnd) break;

      const lenStr = raw.substring(idx + 4, idx + 7).trim();
      const len = parseInt(lenStr, 10);
      if (!isNaN(len) && len >= 7 && len <= 1000) {
        // Extract from the FULL raw stream, not just the container
        const embedded = raw.substring(idx, idx + len);
        if (embedded.length >= 7) {
          records.push(embedded);
        }
      }
      searchPos = idx + 1;
    }
  }
}

// =============================================================================
// MAIN PARSER
// =============================================================================

/**
 * Parse an entire AL3 file into parsed transactions.
 * Splits by transaction boundaries (2TRG...3MTG) and parses each.
 * Handles both line-delimited and concatenated (no-newline) AL3 formats.
 */
export function parseAL3File(content: string): AL3ParsedTransaction[] {
  const lines = splitAL3Records(content);
  const transactions: AL3ParsedTransaction[] = [];

  let currentLines: string[] = [];
  let inTransaction = false;

  let lastTrgLine: string | null = null; // Track 2TRG for multi-2TCG formats

  for (const line of lines) {
    const groupCode = getGroupCode(line);

    if (groupCode === AL3_GROUP_CODES.TRANSACTION_HEADER) {
      // Start a new transaction
      if (inTransaction && currentLines.length > 0) {
        // Close previous (missing trailer)
        const parsed = parseTransaction(currentLines);
        if (parsed) transactions.push(parsed);
      }
      currentLines = [line];
      lastTrgLine = line;
      inTransaction = true;
    } else if (groupCode === '2TCG') {
      // 2TCG = Transaction Content Group. In SAFECO/Universal format, each 2TCG
      // represents a separate policy/insured within the same file.
      // Start a new sub-transaction, re-using the last 2TRG header.
      if (inTransaction && currentLines.length > 1) {
        // Close previous transaction
        const parsed = parseTransaction(currentLines);
        if (parsed) transactions.push(parsed);
        // Start new transaction with the same 2TRG header
        currentLines = lastTrgLine ? [lastTrgLine] : [];
      }
      // Include the 2TCG in the new transaction's lines — it contains insured name
      // and address data in EDIFACT format that supplements the 5BIS record.
      currentLines.push(line);
    } else if (groupCode === AL3_GROUP_CODES.MASTER_TRAILER) {
      if (inTransaction) {
        currentLines.push(line);
        const parsed = parseTransaction(currentLines);
        if (parsed) transactions.push(parsed);
        currentLines = [];
        inTransaction = false;
      }
    } else if (inTransaction) {
      currentLines.push(line);
    }
    // Lines outside transactions (1MHG headers, etc.) are skipped
  }

  // Handle unclosed transaction
  if (inTransaction && currentLines.length > 0) {
    const parsed = parseTransaction(currentLines);
    if (parsed) transactions.push(parsed);
  }

  return transactions;
}

/**
 * Parse a single transaction (group of lines between 2TRG and 3MTG).
 */
function parseTransaction(lines: string[]): AL3ParsedTransaction | null {
  if (lines.length === 0) return null;

  const headerLine = lines.find((l) => getGroupCode(l) === AL3_GROUP_CODES.TRANSACTION_HEADER);
  if (!headerLine) return null;

  const header = parseTransactionHeader(headerLine);
  const coverages: AL3Coverage[] = [];
  const vehicles: AL3Vehicle[] = [];
  const drivers: AL3Driver[] = [];
  const locations: AL3Location[] = [];
  const remarks: string[] = [];
  const claims: AL3Claim[] = [];
  const endorsementRecords: AL3Endorsement[] = [];
  const discountRecords: AL3Discount[] = [];
  const mortgagees: AL3Mortgagee[] = [];
  let insuredAddress: AL3Location | undefined;
  let insuredEmail: string | undefined;
  let insuredPhone: string | undefined;
  let totalPremium: number | undefined;

  let currentVehicle: AL3Vehicle | null = null;
  let confidence = 0.7; // Base confidence

  // Allstate EDIFACT: track when we enter an auto section within a home transaction.
  // Auto sections start with 5ISI followed by 5PPH/6PDR/6PDA and contain 6CVA records.
  // These auto coverages should be excluded from homeowners transactions.
  let inAutoSection = false;
  let hasHomeCoverages = false;
  let seenHomeRecord = false; // Tracks whether we've encountered a home record in the main loop
  // First pass: check if this transaction has any 6CVH (home) records.
  // Also check for 6CVH sub-records embedded inside 6HRU/5REP lines.
  for (const line of lines) {
    const gc = getGroupCode(line);
    if (gc === '6CVH') { hasHomeCoverages = true; break; }
    if ((gc === '6HRU' || gc === '6FRU' || gc === '5REP') && line.includes('6CVH')) {
      hasHomeCoverages = true; break;
    }
  }

  for (const line of lines) {
    const groupCode = getGroupCode(line);

    // Allstate EDIFACT auto section detection: 5ISI followed by auto-specific records
    // marks the start of an auto section within a home transaction.
    // 9BIS or 5BPI with HOME LOB resets back to home section.
    if (hasHomeCoverages) {
      // Track when we've seen a home-specific record (6CVH, 6HRU, 6FRU, 5REP with coverages)
      if (groupCode === '6CVH' || ((groupCode === '6HRU' || groupCode === '6FRU' || groupCode === '5REP') && line.includes('6CVH'))) {
        seenHomeRecord = true;
      }

      if (groupCode === '5ISI') {
        // 5ISI can appear at the start (before home coverages) — only mark as auto
        // when it appears AFTER home-specific records have been seen
        if (seenHomeRecord) {
          inAutoSection = true;
        }
      } else if (groupCode === '5PPH' || groupCode === '6PDR' || groupCode === '6PDA') {
        // Auto-specific record types confirm we're in auto section
        if (inAutoSection) { /* stay in auto section */ }
      } else if (groupCode === '9BIS' || groupCode === '6CVH') {
        // Home-specific records reset to home section
        inAutoSection = false;
      }
    }

    // Skip auto-specific records when in a home transaction's auto section
    if (hasHomeCoverages && inAutoSection) {
      const gc = getGroupCode(line);
      if (gc === '6CVA' || gc === '5PPH' || gc === '6PDR' || gc === '6PDA' ||
          gc === '6PVH' || gc === '5DRV' || gc === '5VEH' || gc === '5BPI') {
        continue; // Skip auto records in home transactions
      }
      // Also skip 5AOI/9AOI in auto section (auto lienholder, not home mortgagee)
      if (gc === '5AOI' || gc === '9AOI') {
        continue;
      }
    }

    switch (groupCode) {
      case AL3_GROUP_CODES.COVERAGE: {
        const cov = parseCoverage(line);
        if (cov) {
          if (currentVehicle) {
            currentVehicle.coverages.push(cov);
          } else {
            coverages.push(cov);
          }
        }
        break;
      }

      case AL3_GROUP_CODES.VEHICLE: {
        // Save previous vehicle
        if (currentVehicle) vehicles.push(currentVehicle);
        currentVehicle = parseVehicle(line);
        break;
      }

      case AL3_GROUP_CODES.DRIVER: {
        const drv = parseDriver(line);
        if (drv) drivers.push(drv);
        break;
      }

      case AL3_GROUP_CODES.SUPPLEMENTARY_DRIVER: {
        // 6SDV: Commercial supplementary driver record
        // Format: 6SDV256 D ... 0001????P        FIRSTNAME                  LASTNAME                DOB
        const drv = parseSupplementaryDriver(line);
        if (drv) drivers.push(drv);
        break;
      }

      case AL3_GROUP_CODES.COMMERCIAL_VEHICLE: {
        // 5CAR: Commercial auto vehicle record
        // Save previous vehicle
        if (currentVehicle) vehicles.push(currentVehicle);
        currentVehicle = parseCommercialVehicle(line);
        break;
      }

      case AL3_GROUP_CODES.LOCATION: {
        const loc = parseLocation(line);
        if (loc) locations.push(loc);
        break;
      }

      case AL3_GROUP_CODES.REMARK: {
        const remark = line.substring(4).trim();
        if (remark) remarks.push(remark);
        break;
      }

      case AL3_GROUP_CODES.DISCOUNT: {
        const disc = parseDiscount(line);
        if (disc) discountRecords.push(disc);
        break;
      }

      case AL3_GROUP_CODES.CLAIM: {
        const clm = parseClaim(line);
        if (clm) claims.push(clm);
        break;
      }

      case AL3_GROUP_CODES.ENDORSEMENT: {
        const end = parseEndorsement(line);
        if (end) endorsementRecords.push(end);
        break;
      }

      case AL3_GROUP_CODES.PREMIUM: {
        // Try to extract total premium from premium record
        const premiumStr = line.substring(4).trim();
        const premium = parseAL3Number(premiumStr);
        if (premium && !header.policyNumber) {
          // Fallback premium extraction
        }
        break;
      }

      case AL3_GROUP_CODES.BUSINESS_INFO_SEGMENT: {
        // 5BIS contains insured name(s).
        // Reference positions: 29=entity type, 38-62=first name, 63-87=last name
        // Two format variants:
        //   Standard: position-based extraction using BIS_FIELDS
        //   SAFECO/Universal: name at pos 18+ delimited by field separators (0xFA)
        // Strategy: try position-based first, then content-based regex fallback
        if (!header.insuredName && line.length > 20) {
          let nameResult: string | null = null;

          // Attempt 0: EDIFACT (Allstate) — parse 0xFA-delimited segments for name
          if (isEDIFACTFormat(line)) {
            const segments = parseEDIFACTSegments(line);
            // Skip REF, skip entity type (single char like "P" or "C"),
            // then collect consecutive alpha name parts (first, middle, last)
            const nameParts: string[] = [];
            let pastEntityType = false;
            for (const seg of segments) {
              if (seg.tag === 'REF') continue;
              // Entity type is a single char (P, C, G)
              if (!pastEntityType && /^[PCGIN]$/.test(seg.data)) {
                pastEntityType = true;
                continue;
              }
              pastEntityType = true;
              // Stop at non-name segments: numeric, codes, addresses, embedded records
              if (/^\d+[+-]?$/.test(seg.data)) break;
              if (/^[A-Z]{1,2}\d{4,}/.test(seg.data)) break;
              if (/\d/.test(seg.data) && /[a-zA-Z]/.test(seg.data)) break; // address
              // Name part: alphabetic text
              if (/^[A-Za-z][A-Za-z .'\-]*$/.test(seg.data)) {
                // Skip known non-name codes (2 char entity/status codes)
                if (/^(IN|FL|OUT|SEP|HOS|POT)$/i.test(seg.data)) break;
                nameParts.push(seg.data.trim());
              } else if (seg.data.length === 0) {
                // Empty segment (e.g., suffix) — skip but don't break
                continue;
              } else {
                break; // Non-name segment reached
              }
            }
            if (nameParts.length > 0) {
              let name = nameParts.filter(p => p.length > 0).join(' ').replace(/\s+/g, ' ').trim();
              // Strip leading entity type char if attached to first name part (e.g., "CHelen" → "Helen")
              if (/^[PCGIRFN][A-Z][a-z]/.test(name)) {
                name = name.substring(1);
              }
              // Also handle "R P FirstName" pattern (separate entity type chars)
              name = name.replace(/^[PCGIRFN]\s+[PCGIRFN]\s+/i, '').trim();
              if (name.length > 2) nameResult = name;
            }
          }

          // Attempt 1: Position-based — try reference positions first, then wider range
          if (!nameResult && line.length > 63) {
            const entityType = extractField(line, BIS_FIELDS.ENTITY_TYPE);

            if (entityType === 'C' || entityType === 'G') {
              // Company/Group: name starts at 31 (right after entity type at 30)
              const companyName = line.substring(31, 88)
                .replace(/[\x00-\x1F\x7F-\xFF]/g, ' ')
                .replace(/\?+/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
              if (companyName && companyName.length > 2 && /[a-zA-Z]{2,}/.test(companyName)) {
                nameResult = companyName;
              }
            } else {
              // Person: read positions 39-98 as single name field (matches DRV approach)
              // then collapse whitespace to merge first + last name
              let rawName = line.substring(39, Math.min(line.length, 98))
                .replace(/[\x00-\x1F\x7F-\xFF]/g, ' ')
                .replace(/\?+/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
              // Clean trailing record artifacts
              rawName = rawName.replace(/\s+[0-9A-F]{2}(\s+\S{1,4})*\s*$/, '').trim();
              rawName = rawName.replace(/\d[A-Z]{3}\d{3}.*/, '').trim();

              if (rawName.length > 2 && /[a-zA-Z]{3,}/.test(rawName) && !/^\d/.test(rawName) && !/^[a-z]\s\d/.test(rawName)) {
                nameResult = rawName;
              }
            }
          }

          // Attempt 2: Content-based (SAFECO format — find name between control chars)
          if (!nameResult) {
            const printable = line
              .replace(/[\x00-\x1F\x7F-\xFF]/g, '\n')
              .split('\n')
              .map(s => s.trim())
              .map(s => s.replace(/^[0-9A-F]{2}\s+/, ''))
              .filter(s => s.length > 2);
            for (const segment of printable) {
              if (/^\d[A-Z]{3}/.test(segment)) continue;
              if (/^[A-Z]{3,4}\d{3}/.test(segment)) continue;
              if (/^\d+$/.test(segment)) continue;
              if (/^[A-Z]{1,2}\d{4,}/.test(segment)) continue;
              const nameMatch = segment.match(/^[CP]?([A-Za-z][A-Za-z .'\-]+[A-Za-z])$/);
              if (nameMatch) {
                let name = nameMatch[0];
                if (/^[CP][A-Z][a-z]/.test(name)) name = name.substring(1);
                nameResult = name.replace(/\s+/g, ' ').trim();
                break;
              }
            }
          }

          if (nameResult) {
            header.insuredName = nameResult;
          }
        }

        // For EDIFACT format: also extract address and embedded policy data from 5BIS
        // (outside the name guard so address is always extracted even if name came from 2TCG)
        if (isEDIFACTFormat(line)) {
          if (!insuredAddress) {
            const addrResult = parseAllstateAddress(line);
            if (addrResult) {
              insuredAddress = addrResult.location;
              if (!insuredPhone && addrResult.phone) insuredPhone = addrResult.phone;
            }
          }
          // Extract policy number from embedded 5BPI data within 5BIS/5ISI
          // Pattern: "5BPI...<spaces>POLICYNUMBER"
          if (!header.policyNumber) {
            const cleanLine = line.replace(/[\x00-\x1F\x7F-\xFF]/g, ' ');
            const policyMatch = cleanLine.match(/5BPI\d{3}[^]*?\s{2,}(\d[\d-]{5,15}\d)\b/);
            if (policyMatch) header.policyNumber = policyMatch[1];
          }
          // Extract LOB and dates from embedded 5BPI data
          if (!header.lineOfBusiness || !header.effectiveDate) {
            const cleanLine = line.replace(/[\x00-\x1F\x7F-\xFF]/g, ' ');
            if (!header.lineOfBusiness) {
              const lobMatch = cleanLine.match(/\b(HOME|AUTO|FIRE|FLOOD)\b/i);
              if (lobMatch) header.lineOfBusiness = LOB_CODES[lobMatch[1].toUpperCase()] || lobMatch[1];
            }
            // Look for YYMMDDYYMMDD date pairs
            const dateMatch = cleanLine.match(/(\d{6})(\d{6})\s*$/m) || cleanLine.match(/(\d{6})(\d{6})/);
            if (dateMatch) {
              if (!header.effectiveDate) {
                const yy = parseInt(dateMatch[1].substring(0, 2), 10);
                const yyyy = yy > 50 ? 1900 + yy : 2000 + yy;
                header.effectiveDate = parseAL3Date(`${yyyy}${dateMatch[1].substring(2)}`);
              }
              if (!header.expirationDate) {
                const yy = parseInt(dateMatch[2].substring(0, 2), 10);
                const yyyy = yy > 50 ? 1900 + yy : 2000 + yy;
                header.expirationDate = parseAL3Date(`${yyyy}${dateMatch[2].substring(2)}`);
              }
            }
          }
        }
        break;
      }

      case AL3_GROUP_CODES.COVERAGE_VEHICLE: {
        // 6CVA: vehicle-level coverage with premium and limit
        if (isEDIFACTFormat(line)) {
          // EDIFACT (Allstate): multiple coverages packed in one record line
          const cvaList = parseEDIFACTHomeCoverages(line);
          for (const cva of cvaList) {
            if (currentVehicle) {
              currentVehicle.coverages.push(cva);
            } else {
              coverages.push(cva);
            }
          }
        } else {
          const cva = parse6LevelCoverage(line, 'vehicle');
          if (cva) {
            if (currentVehicle) {
              currentVehicle.coverages.push(cva);
            } else {
              coverages.push(cva);
            }
          }
        }
        break;
      }

      case AL3_GROUP_CODES.COVERAGE_HOME: {
        // 6CVH: home coverage record
        if (isEDIFACTFormat(line)) {
          // EDIFACT (Allstate): multiple coverages packed in one record line
          const cvhList = parseEDIFACTHomeCoverages(line);
          coverages.push(...cvhList);
        } else {
          const cvh = parse6LevelCoverage(line, 'home');
          if (cvh) {
            coverages.push(cvh);
          }
        }
        break;
      }

      case AL3_GROUP_CODES.FORM: {
        // 5FOR: form/endorsement schedule — extract as endorsement
        const form = parseForm(line);
        if (form) endorsementRecords.push(form);
        break;
      }

      case AL3_GROUP_CODES.BUSINESS_PURPOSE_INFO: {
        // 5BPI: Policy number, dates, premium, LOB
        // Position-based extraction first, then regex fallback
        if (line.length > 49) {
          // Policy number at positions 24-48 (25 chars)
          if (!header.policyNumber) {
            let policyNum = extractField(line, BPI_FIELDS.POLICY_NUMBER)
              .replace(/\?+/g, '')
              .trim();
            // Strip leading reference prefix (e.g., "01    " or "F10001") before actual policy number
            policyNum = policyNum.replace(/^[A-Z]?\d{1,2}\s{2,}/, '').trim();
            if (policyNum && policyNum.length >= 5 && /[A-Z0-9]/.test(policyNum)) {
              header.policyNumber = policyNum;
            }
          }

          // LOB from BPI positions 64-68 (more authoritative than 2TRG header)
          if (line.length > 69) {
            const bpiLob = extractField(line, BPI_FIELDS.LOB_CODE).replace(/\?+/g, '').trim();
            if (bpiLob && LOB_CODES[bpiLob]) {
              header.lineOfBusiness = LOB_CODES[bpiLob];
            }
          }

          // Effective date from BPI (YYMMDD at 73-78 or YYYYMMDD in extended portion)
          if (!header.effectiveDate && line.length > 79) {
            const effShort = extractField(line, BPI_FIELDS.EFF_DATE_SHORT);
            if (effShort && /^\d{6}$/.test(effShort)) {
              const yy = parseInt(effShort.substring(0, 2), 10);
              const yyyy = yy > 50 ? 1900 + yy : 2000 + yy;
              header.effectiveDate = parseAL3Date(`${yyyy}${effShort.substring(2)}`);
            }
          }

          // Expiration date from BPI (YYMMDD at 79-84)
          if (!header.expirationDate && line.length > 85) {
            const expShort = extractField(line, BPI_FIELDS.EXP_DATE_SHORT);
            if (expShort && /^\d{6}$/.test(expShort)) {
              const yy = parseInt(expShort.substring(0, 2), 10);
              const yyyy = yy > 50 ? 1900 + yy : 2000 + yy;
              header.expirationDate = parseAL3Date(`${yyyy}${expShort.substring(2)}`);
            }
          }
        }

        // EDIFACT (Allstate) branch: extract LOB and dates from segments
        if (isEDIFACTFormat(line)) {
          const segments = parseEDIFACTSegments(line);
          for (const seg of segments) {
            if (seg.tag === 'REF') continue;
            // LOB: segment containing HOME/AUTO/FIRE/FLOOD
            if (!header.lineOfBusiness) {
              const lobMatch = seg.data.match(/\b(HOME|AUTO|FIRE|FLOOD)\b/i);
              if (lobMatch) {
                header.lineOfBusiness = LOB_CODES[lobMatch[1].toUpperCase()] || lobMatch[1];
              }
            }
            // Dates: YYMMDD (6 digits) — first=effective, second=expiration
            // Also check for combined "YYMMDDYYMMDD" (12 digits) pattern
            if (!header.effectiveDate || !header.expirationDate) {
              const combinedMatch = seg.data.match(/(\d{6})(\d{6})/);
              if (combinedMatch) {
                if (!header.effectiveDate) {
                  const yy = parseInt(combinedMatch[1].substring(0, 2), 10);
                  const yyyy = yy > 50 ? 1900 + yy : 2000 + yy;
                  header.effectiveDate = parseAL3Date(`${yyyy}${combinedMatch[1].substring(2)}`);
                }
                if (!header.expirationDate) {
                  const yy = parseInt(combinedMatch[2].substring(0, 2), 10);
                  const yyyy = yy > 50 ? 1900 + yy : 2000 + yy;
                  header.expirationDate = parseAL3Date(`${yyyy}${combinedMatch[2].substring(2)}`);
                }
              } else if (/^\d{6}$/.test(seg.data)) {
                const yy = parseInt(seg.data.substring(0, 2), 10);
                const yyyy = yy > 50 ? 1900 + yy : 2000 + yy;
                const parsed = parseAL3Date(`${yyyy}${seg.data.substring(2)}`);
                if (parsed) {
                  if (!header.effectiveDate) {
                    header.effectiveDate = parsed;
                  } else if (!header.expirationDate) {
                    header.expirationDate = parsed;
                  }
                }
              }
            }
          }
        }

        // Regex fallback for policy number
        if (!header.policyNumber) {
          const bpiContent = line.substring(7);
          const policyMatch = bpiContent.match(/\b([A-Z]{1,3}\d{5,15})\b/);
          if (policyMatch) {
            header.policyNumber = policyMatch[1];
          } else {
            // Match numeric or hyphenated policy numbers (e.g., "0301-2100-0999")
            const altMatch = bpiContent.match(/\b(\d[\d-]{5,15}\d)\b/);
            if (altMatch) header.policyNumber = altMatch[1];
          }
        }
        // Regex fallback for LOB
        if (!header.lineOfBusiness) {
          const lobMatch = line.match(/\b(HOME|AUTOP?|PAUTO|CAUTO|PHOME|FIRE|FLOOD|BOAT)\b/i);
          if (lobMatch) {
            header.lineOfBusiness = LOB_CODES[lobMatch[1].toUpperCase()] || lobMatch[1];
          }
        }

        // PREMIUM EXTRACTION - this is the authoritative policy premium
        // AL3 5BPI format: positions 109-120 = annual premium (11 digits + sign, cents)
        // Universal pattern fallback: look for 11-digit premium patterns like "00000238000+"
        if (!totalPremium && line.length > 120) {
          // Look for 11-digit number followed by +/- sign (standard AL3 premium format)
          // Must be 11 digits to avoid matching dates (8 digits) or other numbers
          const premiumPatterns = line.substring(100).match(/(\d{11})[+-]/g);
          if (premiumPatterns && premiumPatterns.length > 0) {
            for (const pattern of premiumPatterns) {
              const rawPremium = pattern.replace(/[+-]$/, '');
              const val = parseInt(rawPremium, 10);
              // Validate: reasonable premium range ($50 - $100,000)
              const dollars = val / 100;
              if (dollars >= 50 && dollars <= 100000) {
                totalPremium = dollars;
                break;
              }
            }
          }
        }
        // EDIFACT fallback: Allstate uses different format
        if (!totalPremium && isEDIFACTFormat(line)) {
          const segments = parseEDIFACTSegments(line);
          for (const seg of segments) {
            // Look for premium in segment data: 8-10 digits ending with +/-
            const match = seg.data.match(/^(\d{7,10})[+-]$/);
            if (match) {
              const val = parseInt(match[1], 10);
              const dollars = val / 100;
              if (dollars >= 50 && dollars <= 100000) {
                totalPremium = dollars;
                break;
              }
            }
          }
        }
        break;
      }

      default: {
        // Handle record types by their 4-char group code prefix
        const gc = getGroupCode(line);

        if (gc === '9BIS' && !insuredAddress) {
          // 9BIS: Insured address continuation
          // Try EDIFACT (Allstate) first
          if (isEDIFACTFormat(line)) {
            const result = parseAllstateAddress(line);
            if (result) {
              insuredAddress = result.location;
              if (!insuredPhone && result.phone) insuredPhone = result.phone;
            }
          } else {
            insuredAddress = parseBISAddress(line) ?? undefined;
          }
          // Extract phone from 9BIS if available (position-based fallback)
          if (!insuredPhone && insuredAddress && !isEDIFACTFormat(line)) {
            const fields = line.length > 130 ? BIS_ADDRESS_FIELDS : BIS_ADDRESS_FIELDS_SHORT;
            const phone = extractField(line, fields.PHONE).replace(/\?+/g, '').trim();
            if (phone && /^\d{7,}$/.test(phone)) {
              insuredPhone = phone;
            }
          }
        } else if (gc === '5ISI' && isEDIFACTFormat(line)) {
          // 5ISI: Insured Supplemental Info — may contain embedded 5BPI with policy number
          if (!header.policyNumber) {
            const cleanLine = line.replace(/[\x00-\x1F\x7F-\xFF]/g, ' ');
            const policyMatch = cleanLine.match(/5BPI\d{3}[^]*?\s{2,}(\d[\d-]{5,15}\d)\b/);
            if (policyMatch) header.policyNumber = policyMatch[1];
          }
        } else if (gc === '5AOI') {
          // 5AOI: Additional Other Insured (mortgagee/lienholder)
          const mortgagee = parseMortgagee(line);
          if (mortgagee) mortgagees.push(mortgagee);
        } else if (gc === '6COM') {
          // 6COM: Communication record (email, phone)
          if (isEDIFACTFormat(line)) {
            // EDIFACT (Allstate): extract type and value from segments
            const segments = parseEDIFACTSegments(line);
            let commType = '';
            let commValue = '';
            for (const seg of segments) {
              if (seg.tag === 'REF') continue;
              if (/\b(EMAIL|PHONE|CELL)\b/i.test(seg.data)) {
                commType = seg.data.match(/\b(EMAIL|PHONE|CELL)\b/i)?.[1]?.toUpperCase() || '';
              } else if (seg.data.includes('@')) {
                commValue = seg.data;
              } else if (/^\d{10,}$/.test(seg.data)) {
                commValue = seg.data;
              }
            }
            if (commType === 'EMAIL' && commValue && commValue.includes('@')) {
              insuredEmail = commValue.toLowerCase();
            } else if ((commType === 'PHONE' || commType === 'CELL') && commValue && /^\d{7,}$/.test(commValue)) {
              if (!insuredPhone) insuredPhone = commValue;
            }
          } else {
            const commType = extractField(line, COM_FIELDS.COMM_TYPE).toUpperCase();
            const commValue = extractField(line, COM_FIELDS.VALUE).replace(/\?+/g, '').trim();
            if (commType === 'EMAIL' && commValue && commValue.includes('@')) {
              insuredEmail = commValue.toLowerCase();
            } else if ((commType === 'PHONE' || commType === 'CELL') && commValue && /^\d{7,}$/.test(commValue)) {
              if (!insuredPhone) insuredPhone = commValue;
            }
          }
        } else if (gc === '5RMK') {
          // 5RMK: Remarks — proper parsing + email extraction
          const remarkText = extractField(line, RMK_FIELDS.TEXT).replace(/\?+/g, ' ').replace(/\s+/g, ' ').trim();
          if (remarkText) {
            remarks.push(remarkText);
            // Extract email from remark text if not already found
            if (!insuredEmail) {
              const emailMatch = remarkText.match(/[\w.+-]+@[\w.-]+\.[a-zA-Z]{2,}/);
              if (emailMatch) insuredEmail = emailMatch[0].toLowerCase();
            }
          }
        } else if (gc === '2TCG' && isEDIFACTFormat(line)) {
          // 2TCG: Transaction Content Group — in Allstate EDIFACT, contains insured name
          // and address data that supplements (and may be more complete than) the 5BIS record.
          // Extract name from segments: tag 08=first name, 0A/0B/0C=last name parts
          if (!header.insuredName || header.insuredName.split(' ').length <= 1) {
            const segments = parseEDIFACTSegments(line);
            const nameParts: string[] = [];
            let pastEntityType = false;
            for (const seg of segments) {
              if (seg.tag === 'REF' || seg.tag === 'SUB') continue;
              // Entity type: single char P, C, F, G
              if (!pastEntityType && /^[PCFGIN]$/.test(seg.data)) {
                pastEntityType = true;
                continue;
              }
              pastEntityType = true;
              // Stop at non-name data
              if (/^\d+[+-]?$/.test(seg.data)) break;
              if (/^[A-Z]{1,2}\d{4,}/.test(seg.data)) break;
              if (/\d/.test(seg.data) && /[a-zA-Z]/.test(seg.data)) break;
              if (/^(IN|FL|OUT|SEP|HOS|POT)$/i.test(seg.data)) break;
              // Embedded record header
              if (/^\d[A-Z]{3}\d{3}/.test(seg.data)) break;
              if (/^[A-Za-z][A-Za-z .&'\-]*$/.test(seg.data)) {
                nameParts.push(seg.data.trim());
              } else if (seg.data.length === 0) {
                continue;
              } else {
                break;
              }
            }
            if (nameParts.length > 0) {
              const name = nameParts.filter(p => p.length > 0).join(' ').replace(/\s+/g, ' ').trim();
              if (name.length > 2) header.insuredName = name;
            }
          }
        } else if (gc === '5LAG') {
          // 5LAG: Location Address Group — use proper reference positions
          const loc = parseLAGLocation(line);
          if (loc) locations.push(loc);
        } else if ((gc === '6HRU' || gc === '6FRU') && isEDIFACTFormat(line)) {
          // 6HRU/6FRU: Home/Fire Underwriting — may contain embedded 5AOI mortgagee data
          // AND embedded 6CVH coverage sub-records (DWELL, OS, CONT, LOU, PL).
          // In Allstate EDIFACT, the mortgagee name is embedded in a segment containing "5AOI"
          // Pattern: "50?5AOI204 6 R200016HRUR10001    001MG01?CHometown Bank Of Alabama"
          const rawParts: string[] = [];
          let partStart = 0;
          for (let i = 0; i < line.length; i++) {
            if (line.charCodeAt(i) === 0xFA) {
              rawParts.push(line.substring(partStart, i));
              partStart = i + 1;
            }
          }
          rawParts.push(line.substring(partStart));

          for (const part of rawParts) {
            // Look for segments containing embedded 5AOI with mortgagee data
            // Pattern: "50?5AOI...001MG01?C<name>" or "50?5AOI...001LP01?C<name>"
            const aoiMatch = part.match(/5AOI\d{3}[^]*?001([A-Z]{2})01\?([CP])(.+)/);
            if (aoiMatch) {
              const interestType = aoiMatch[1]; // MG, LP, etc.
              let name = aoiMatch[3].replace(/[\x00-\x1F\x7F-\xFF]/g, '').trim();
              // Clean trailing noise
              name = name.replace(/\d[A-Z]{3}\d{3}.*$/, '').trim();
              if (name.length > 2) {
                mortgagees.push({
                  interestType,
                  name,
                });
              }
            }
          }

          // Also extract loan number from segments with tag "12"
          // Pattern: "12?40821544 1"
          if (mortgagees.length > 0) {
            const lastMortgagee = mortgagees[mortgagees.length - 1];
            if (!lastMortgagee.loanNumber) {
              for (const part of rawParts) {
                const clean = part.replace(/[\x00-\x1F\x7F-\xFF]/g, '').trim();
                const loanMatch = clean.match(/^12\?(\d{5,})/);
                if (loanMatch) {
                  lastMortgagee.loanNumber = loanMatch[1];
                  break;
                }
              }
            }
          }

          // Extract embedded 6CVH coverage sub-records from 6HRU/6FRU lines.
          // Some carriers pack the first few coverages (DWELL, OS, CONT, LOU, PL)
          // inside the 6HRU line rather than as standalone 6CVH lines.
          if (line.includes('6CVH')) {
            const cvhList = parseEDIFACTHomeCoverages(line);
            coverages.push(...cvhList);
          }
        } else if (gc === '5REP' && isEDIFACTFormat(line) && line.includes('6CVH')) {
          // 5REP: Replacement cost/property report — some carriers (CAN STRATEGIC)
          // embed the first coverage sub-records (DWELL, OS, PP) inside this line.
          const cvhList = parseEDIFACTHomeCoverages(line);
          coverages.push(...cvhList);
        }
        break;
      }
    }
  }

  // Save last vehicle
  if (currentVehicle) vehicles.push(currentVehicle);

  // Deduplicate coverages (EDIFACT records can produce duplicates from overlapping record splits)
  const seen = new Set<string>();
  const uniqueCoverages: AL3Coverage[] = [];
  for (const c of coverages) {
    const key = `${c.code}|${c.premium ?? ''}|${c.limitAmount ?? ''}|${c.description ?? ''}`;
    if (!seen.has(key)) {
      seen.add(key);
      uniqueCoverages.push(c);
    }
  }

  // Reclassify LOB based on actual coverage records (overrides potentially wrong 2TRG LOB)
  if (hasHomeCoverages) {
    // Home coverages present — ensure LOB reflects that (fixes misaligned 2TRG LOB codes like "UM")
    if (!header.lineOfBusiness || header.lineOfBusiness === 'Umbrella' || header.lineOfBusiness === 'Personal Auto') {
      header.lineOfBusiness = 'Homeowners';
    }
  } else if (uniqueCoverages.length > 0) {
    const autoCodes = new Set(['BI', 'PD', 'COLL', 'COMP', 'UM', 'MEDPM', 'RREIM', 'TL', 'EXTCV']);
    const hasAutoCode = uniqueCoverages.some(c =>
      autoCodes.has(c.code.toUpperCase()) || autoCodes.has(c.description?.toUpperCase() || '')
    );
    if (hasAutoCode) {
      header.lineOfBusiness = 'Personal Auto';
    }
  }

  // Adjust confidence based on data completeness
  if (header.policyNumber && header.transactionType) confidence += 0.1;
  if (coverages.length > 0 || vehicles.length > 0) confidence += 0.1;
  if (header.effectiveDate) confidence += 0.05;
  if (insuredAddress) confidence += 0.05;
  confidence = Math.min(confidence, 1.0);

  return {
    header,
    coverages: uniqueCoverages,
    vehicles,
    drivers,
    locations,
    remarks,
    claims,
    endorsementRecords,
    discountRecords,
    mortgagees,
    insuredAddress,
    insuredEmail,
    insuredPhone,
    rawContent: lines.join('\n'),
    parseConfidence: confidence,
    totalPremium,
  };
}

/**
 * Parse a transaction header line (2TRG).
 * In IVANS AL3 format (212-byte records), the key fields are:
 *   167-169: transaction type (RWL, PCH, COM, etc.)
 *   204-211: effective date (YYYYMMDD)
 *   47-79:   carrier company name
 *   24-28:   LOB sub-code (PAUTO, PHOME, CAUTO)
 * Policy number and insured name are NOT in the 2TRG — they come from 5BPI/5BIS records.
 */
function parseTransactionHeader(line: string): AL3TransactionHeader {
  const transactionType = extractField(line, TRG_FIELDS.TRANSACTION_TYPE);
  const carrierCode = extractField(line, TRG_FIELDS.COMPANY_CODE);
  const carrierName = extractField(line, TRG_FIELDS.COMPANY_NAME);
  const effectiveDateRaw = extractField(line, TRG_FIELDS.EFFECTIVE_DATE);
  const lobCode = extractField(line, TRG_FIELDS.LOB_CODE);

  // Clean carrier name: strip trailing producer codes after long whitespace runs
  let cleanCarrierName = carrierName || '';
  const spaceRun = cleanCarrierName.match(/^(.+?)\s{3,}/);
  if (spaceRun) cleanCarrierName = spaceRun[1].trim();
  if (!cleanCarrierName || /^IBM/i.test(cleanCarrierName)) cleanCarrierName = '';
  // Fix truncated carrier names from EDIFACT-delimited records
  if (cleanCarrierName === 'LSTATE') cleanCarrierName = 'ALLSTATE';
  if (cleanCarrierName === 'CAN STRATEGIC') cleanCarrierName = 'AMERICAN STRATEGIC';
  if (cleanCarrierName === 'RSAL P&C INS CO') cleanCarrierName = 'UNIVERSAL P&C INS CO';

  // Fallback: try extracting LOB from anywhere in the first 40 chars if position-based failed
  let resolvedLob = LOB_CODES[lobCode] || lobCode || undefined;
  if (!resolvedLob || resolvedLob === lobCode) {
    const lobMatch = line.substring(0, 40).match(/\b(PHOME|PAUTO|CAUTO|HOME|AUTO)\b/i);
    if (lobMatch) resolvedLob = LOB_CODES[lobMatch[1].toUpperCase()] || lobMatch[1];
  }

  const header: AL3TransactionHeader = {
    transactionType: transactionType || 'UNKNOWN',
    policyNumber: '',
    carrierCode: carrierCode || '',
    carrierName: cleanCarrierName || undefined,
    lineOfBusiness: resolvedLob,
    effectiveDate: parseAL3Date(effectiveDateRaw),
    insuredName: undefined,
  };

  // Fallback: regex-based transaction type (for non-standard record formats or
  // EDIFACT-delimited formats where position-based extraction yields garbage)
  if (!transactionType || header.transactionType === 'UNKNOWN' || /^\d+$/.test(header.transactionType) || /[^\x20-\x7E]/.test(header.transactionType)) {
    const txMatch = line.match(/\b(RWL|RWQ|RNW|NBS|NBQ|END|ENQ|CAN|REI|AUD|INQ|PCH|COM)\b/);
    if (txMatch) header.transactionType = txMatch[1];
  }

  // Fallback: regex-based carrier name extraction
  // Trigger if name is missing, contains non-printable chars, or looks like a truncated fragment
  if (!header.carrierName || /[^\x20-\x7E]/.test(header.carrierName) || (header.carrierName.length < 20 && /^[A-Z]{3,}/.test(header.carrierName) === false)) {
    const cleanLine = line.replace(/[^\x20-\x7E]/g, ' ');
    const nameMatch = cleanLine.match(/([A-Z][A-Z &.']+(?:INS(?:URANCE)?|MUTUAL|ASSURANCE|INDEMNITY|CASUALTY|P&C|FIRE|GROUP|SURETY)[A-Z &.']*(?: CO| COMPANY| CORP)?)/i);
    if (nameMatch && nameMatch[1].length > (header.carrierName?.length || 0)) {
      // Clean up: if the name starts with a repeated carrier code, trim the prefix
      let name = nameMatch[1].trim();
      // Handle "UNIVUNIVERSAL" → "UNIVERSAL" pattern (carrier code prefix runs into name)
      const repeatMatch = name.match(/^([A-Z]{3,6})\1/i);
      if (repeatMatch) {
        name = name.substring(repeatMatch[1].length);
      }
      header.carrierName = name;
    }
  }

  // Clean up carrier name: strip trailing agency IDs and garbage
  if (header.carrierName) {
    // Strip trailing agency ID patterns like "IBMYX67JQA", "159786", "HAWKSOFT"
    header.carrierName = header.carrierName
      .replace(/IBM[A-Z0-9]{5,}.*$/i, '')  // IBMYX67JQA...
      .replace(/\s*\d{5,}.*$/, '')          // 159786...
      .replace(/\s*HAWKSOFT.*$/i, '')       // HAWKSOFT...
      .replace(/\s*TCDS.*$/i, '')           // TCDS Insurance Agency...
      .trim();
  }

  // Fallback: extract effective date via regex if position-based failed
  if (!header.effectiveDate) {
    // Look for YYYYMMDD dates in the line (2025-2027 range)
    const cleanLine = line.replace(/[^\x20-\x7E]/g, '');
    const dateMatch = cleanLine.match(/(202[5-7][01]\d[0-3]\d)/g);
    if (dateMatch && dateMatch.length >= 1) {
      // Last date in the record is usually the effective date
      header.effectiveDate = parseAL3Date(dateMatch[dateMatch.length - 1]);
    }
  }

  return header;
}

/**
 * Parse a coverage record (5CVG).
 */
function parseCoverage(line: string): AL3Coverage | null {
  const code = extractField(line, CVG_FIELDS.COVERAGE_CODE);
  if (!code) return null;

  const limitStr = extractField(line, CVG_FIELDS.LIMIT);
  const deductibleStr = extractField(line, CVG_FIELDS.DEDUCTIBLE);

  return {
    code,
    description: code,
    limit: limitStr || undefined,
    limitAmount: parseAL3Number(limitStr),
    deductible: deductibleStr || undefined,
    deductibleAmount: parseAL3Number(deductibleStr),
    premium: undefined, // Premiums are in 6CVA records, not 5CVG
  };
}

/**
 * Parse a level-6 coverage record (6CVA or 6CVH).
 * 6CVA: vehicle-level coverage with premium at position 60 and limit at position 90.
 * 6CVH: home coverage with limit at position 60 and secondary amount at position 90.
 */
function parse6LevelCoverage(line: string, type: 'vehicle' | 'home'): AL3Coverage | null {
  const fields = type === 'vehicle' ? CVA_FIELDS : CVH_FIELDS;
  const code = extractField(line, fields.COVERAGE_CODE);
  if (!code) return null;

  if (type === 'vehicle') {
    // 6CVA: premium at 60 (implied 2 decimals + sign), limits at 102+, deductible at 122+
    const premiumStr = extractField(line, CVA_FIELDS.PREMIUM).replace(/[+-]$/, '');
    const limitStr = extractField(line, CVA_FIELDS.LIMIT);
    const limit2Str = extractField(line, CVA_FIELDS.LIMIT_2);
    const deductibleStr = extractField(line, CVA_FIELDS.DEDUCTIBLE);
    const descriptionStr = line.length > 145 ? extractField(line, CVA_FIELDS.DESCRIPTION) : '';
    const premium = parseAL3Number(premiumStr);
    const limitAmount = parseAL3Number(limitStr);
    // Parse deductible: extract leading digits, ignore trailing type codes like "G2", "PR"
    // Format is zero-padded 6 digits (e.g., "000500" = $500)
    const cleanDedStr = deductibleStr.trim();
    const dedDigits = cleanDedStr.match(/^(\d+)/);
    const deductibleAmount = dedDigits && parseInt(dedDigits[1], 10) > 0
      ? parseInt(dedDigits[1], 10)
      : undefined;

    // Use human-readable description from 6CVA if available
    const cleanDesc = descriptionStr
      ?.replace(/[\x00-\x1F\x7F-\xFF]/g, ' ')
      .replace(/\?+/g, '')
      .replace(/\s+/g, ' ')
      .trim();

    // Check if this is a known discount code
    const mappedType = COVERAGE_CODE_MAP[code.toUpperCase()] || COVERAGE_CODE_MAP[code];
    const isDiscountCode = mappedType && DISCOUNT_COVERAGE_TYPES.has(mappedType);

    // Skip truly empty records (no premium, no limit, no deductible, no description)
    // BUT keep discount codes even without numeric values
    if (!premium && !limitAmount && !deductibleAmount && !cleanDesc && !isDiscountCode) return null;

    // Build limit display string for split limits (BI, UM, UMBI)
    // Format: Limit 1 (10 chars) = [7 digits per-person][3 digits per-accident prefix]
    // Limit 2 (5+ chars) = per-accident suffix
    // Example: "0100000003" + "00000" → $100,000/$300,000
    let displayLimit = limitStr || undefined;
    let finalLimitAmount = limitAmount;
    const upperCode = code.toUpperCase();
    const splitLimitCodes = ['BI', 'UM', 'UMBI', 'UMISP', 'UIM'];
    const isSplitLimit = splitLimitCodes.includes(upperCode);
    if (isSplitLimit && limitStr && limitStr.length >= 7) {
      const rawLimit = limitStr.replace(/[^0-9]/g, '');
      if (rawLimit.length >= 7) {
        const perPerson = parseInt(rawLimit.substring(0, 7), 10);
        const perAccidentPrefix = rawLimit.substring(7);
        const rawLimit2 = (limit2Str || '').replace(/[^0-9]/g, '');
        const perAccident = parseInt(perAccidentPrefix + rawLimit2, 10);
        if (perPerson > 0) {
          displayLimit = perAccident > 0 ? `${perPerson}/${perAccident}` : `${perPerson}`;
        }
      }
    }

    // RREIM/RENT: rental reimbursement is daily/max format
    // AL3 stores as "0000050000" which parses to 50000
    // HawkSoft stores "50/1,500" (daily=$50, max=$1500)
    // Known carrier patterns:
    //   - Value divisible by 1000 with daily rate 20-100: daily*1000 encoding
    //   - Value < 200: raw daily amount
    //   - Value >= 200 but not fitting patterns: leave as-is (comparison will flag)
    if ((upperCode === 'RREIM' || upperCode === 'RENT') && limitAmount) {
      if (limitAmount >= 1000 && limitAmount % 1000 === 0) {
        const daily = limitAmount / 1000;
        // Only apply heuristic for reasonable daily rates ($20-$100)
        if (daily >= 20 && daily <= 100) {
          const max = daily * 30;
          displayLimit = `${daily}/${max}`;
          finalLimitAmount = daily;
        }
        // Values like 1000 ($1/day?) or 200000 ($200/day?) are left as-is
      } else if (limitAmount < 200) {
        // Raw daily amount (e.g., 50 → $50/day)
        const daily = limitAmount;
        const max = daily * 30;
        displayLimit = `${daily}/${max}`;
        finalLimitAmount = daily;
      }
      // Values 200-999 or large non-divisible values are left as-is
    }

    // Clean non-split limit strings: strip leading zeros for readable display
    if (displayLimit && !isSplitLimit && !(upperCode === 'RREIM' || upperCode === 'RENT')) {
      const numericOnly = displayLimit.replace(/[^0-9]/g, '');
      if (numericOnly.length > 0 && /^0+\d/.test(numericOnly)) {
        const cleaned = numericOnly.replace(/^0+/, '') || '0';
        displayLimit = cleaned;
      }
    }

    // For discount codes, use a human-readable description from the mapped type
    let finalDescription = cleanDesc || code;
    if (isDiscountCode && mappedType) {
      // Convert 'accident_free_discount' to 'Accident Free Discount'
      finalDescription = mappedType
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }

    return {
      code,
      description: finalDescription,
      limit: displayLimit,
      limitAmount: finalLimitAmount,
      deductible: deductibleStr || undefined,
      deductibleAmount,
      premium: premium ? premium / 100 : undefined, // IVANS premiums are in cents
    };
  } else {
    // 6CVH: home/watercraft coverage record
    // Different carriers use different field positions:
    //   - SAFECO 6CVH240: limit at 60-72, secondary at 90-101
    //   - Openly 6CVH323: limit at ~86, description at ~150
    // Use pattern-based extraction as fallback when fixed positions yield nothing

    // Try fixed positions first (works for SAFECO)
    let primaryStr = extractField(line, CVH_FIELDS.LIMIT);
    let secondaryStr = extractField(line, CVH_FIELDS.SECONDARY_AMOUNT);

    // Detect if primary field is premium (has +/- sign) or limit
    const hasPremiumSign = /[+-]$/.test(primaryStr.trim());

    let premium: number | undefined;
    let limitAmount: number | undefined;
    let limitStr: string | undefined;
    let deductibleAmount: number | undefined;
    let deductibleStr: string | undefined;

    if (hasPremiumSign) {
      // Watercraft format: primary is premium, secondary is limit
      const premiumRaw = primaryStr.replace(/[+-]$/, '');
      premium = parseAL3Number(premiumRaw);
      if (premium) premium = premium / 100;
      limitAmount = parseAL3Number(secondaryStr);
      limitStr = secondaryStr || undefined;
    } else {
      // Home format: primary is limit
      limitAmount = parseAL3Number(primaryStr);
      const secondaryAmount = parseAL3Number(secondaryStr);
      if (!limitAmount && secondaryAmount) {
        limitAmount = secondaryAmount;
        limitStr = secondaryStr;
      } else {
        limitStr = primaryStr || undefined;
      }
    }

    // FALLBACK: Pattern-based extraction for non-standard formats (Openly, etc.)
    // If fixed positions yielded no limit, scan the line for numeric patterns
    if (!limitAmount && line.length > 100) {
      // Extract the data portion after the coverage code (position 45+)
      const dataSection = line.substring(45);

      // AL3 limits are typically 8-digit zero-padded (e.g., "05000000" = $500,000)
      // Openly concatenates limit+deductible like "0500000001000" (limit 8 digits + ded 5 digits)
      // First try to find 8-digit sequences
      const eightDigitPattern = /(\d{8})/g;
      const eightDigitMatches = [...dataSection.matchAll(eightDigitPattern)];

      if (eightDigitMatches.length > 0) {
        // First 8-digit number is the limit
        const rawLimit = eightDigitMatches[0][1];
        const parsedLimit = parseInt(rawLimit.replace(/^0+/, '') || '0', 10);
        if (parsedLimit > 0) {
          limitAmount = parsedLimit;
          limitStr = String(parsedLimit);
        }

        // Check if there's a deductible immediately after the limit (5-7 digits pattern)
        const limitEndPos = (eightDigitMatches[0].index ?? 0) + 8;
        const afterLimit = dataSection.substring(limitEndPos, limitEndPos + 10);
        const dedMatch = afterLimit.match(/^(\d{4,7})/);
        if (dedMatch) {
          const parsedDed = parseInt(dedMatch[1].replace(/^0+/, '') || '0', 10);
          if (parsedDed > 0 && parsedDed <= 25000) {
            deductibleAmount = parsedDed;
            deductibleStr = String(parsedDed);
          }
        }

        // Also check if there's a duplicate limit at end of line (Openly format)
        // This is useful for validation but we don't need to capture it twice
      } else {
        // No 8-digit sequence found, try shorter patterns for deductible-only records
        const shortPattern = /(\d{5,7})/;
        const shortMatch = dataSection.match(shortPattern);
        if (shortMatch) {
          const parsedVal = parseInt(shortMatch[1].replace(/^0+/, '') || '0', 10);
          // Distinguish between small deductibles and larger limits
          if (parsedVal > 0 && parsedVal <= 25000) {
            deductibleAmount = parsedVal;
            deductibleStr = String(parsedVal);
          } else if (parsedVal > 25000) {
            limitAmount = parsedVal;
            limitStr = String(parsedVal);
          }
        }
      }
    }

    // Extract description from end of line (pattern-based)
    // Look for readable text after position 100 (where descriptions typically appear)
    let description = code;
    if (line.length > 150) {
      const endSection = line.substring(100).trim();
      // Find first run of alphabetic text (the description)
      const descMatch = endSection.match(/([A-Z][a-zA-Z]+(?:\s+[A-Za-z]+)*)/);
      if (descMatch && descMatch[1].length > 2) {
        description = descMatch[1].trim();
      }
    }

    // Check if this is a known discount code
    const mappedType = COVERAGE_CODE_MAP[code.toUpperCase()] || COVERAGE_CODE_MAP[code];
    const isDiscountCode = mappedType && DISCOUNT_COVERAGE_TYPES.has(mappedType);

    // Skip records with no useful data, BUT keep discount codes and endorsements
    // Some coverages (sinkhole, mine subsidence) are included even without limits
    const hasDescription = description && description !== code && description.length > 3;
    if (!premium && !limitAmount && !isDiscountCode && !hasDescription) return null;

    // For discount codes, use a human-readable description
    let finalDescription = description;
    if (isDiscountCode && mappedType) {
      finalDescription = mappedType
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }

    return {
      code,
      description: finalDescription,
      limit: limitStr,
      limitAmount,
      deductible: deductibleStr,
      deductibleAmount,
      premium,
    };
  }
}

/**
 * Parse a form/endorsement schedule record (5FOR).
 */
function parseForm(line: string): AL3Endorsement | null {
  // EDIFACT (Allstate): extract form number and description from segments
  if (isEDIFACTFormat(line)) {
    const segments = parseEDIFACTSegments(line);
    let formNumber = '';
    let description = '';
    for (const seg of segments) {
      if (seg.tag === 'REF') continue;
      // Form number: alphanumeric segment (e.g., "A206 AL")
      if (!formNumber && /[A-Z0-9]/.test(seg.data) && seg.data.length <= 20) {
        formNumber = seg.data;
      }
      // Description: longer text segment
      if (!description && /[a-zA-Z]{3,}/.test(seg.data) && seg.data.length > formNumber.length) {
        description = seg.data;
      }
    }
    if (!formNumber && !description) return null;
    return {
      code: formNumber || 'FORM',
      description: description || formNumber || undefined,
      effectiveDate: undefined,
      premium: undefined,
    };
  }

  let formNumber = extractField(line, FOR_FIELDS.FORM_NUMBER);
  let description = extractField(line, FOR_FIELDS.DESCRIPTION);
  if (!formNumber && !description) return null;

  // Clean non-printable characters and ? filler
  if (formNumber) formNumber = formNumber.replace(/[^\x20-\x7E]/g, '').trim() || '';
  if (description) {
    description = description
      .replace(/[^\x20-\x7E]/g, ' ')  // Remove non-printable chars
      .replace(/\?{3,}/g, '')          // Strip runs of 3+ question marks (filler)
      .replace(/\s+/g, ' ')
      .trim() || '';
  }

  return {
    code: formNumber || 'FORM',
    description: description || formNumber || undefined,
    effectiveDate: undefined,
    premium: undefined,
  };
}

/**
 * Parse a vehicle record (5VEH).
 * Uses fixed positions with pattern-based fallbacks for carrier variations.
 */
function parseVehicle(line: string): AL3Vehicle {
  // Try fixed positions first
  let vin = extractField(line, VEH_FIELDS.VIN) || undefined;
  let year = parseAL3Number(extractField(line, VEH_FIELDS.YEAR)) as number | undefined;
  let make = extractField(line, VEH_FIELDS.MAKE) || undefined;
  let model = extractField(line, VEH_FIELDS.MODEL) || undefined;

  // UNIVERSAL FALLBACKS using pattern extraction

  // VIN: 17 alphanumeric characters (no I, O, Q)
  if (!vin || vin.length < 17) {
    const vinMatch = line.match(/[A-HJ-NPR-Z0-9]{17}/);
    if (vinMatch) vin = vinMatch[0];
  }

  // Year: 4-digit number in 1990-2030 range
  if (!year) {
    const yearMatch = line.match(/\b(19[9]\d|20[0-3]\d)\b/);
    if (yearMatch) year = parseInt(yearMatch[1], 10);
  }

  // Make/Model: Look for known auto manufacturer names if not found
  const cleanLine = line.replace(/[^\x20-\x7E]/g, ' ');
  if (!make) {
    const makePatterns = [
      'TOYOTA', 'HONDA', 'FORD', 'CHEVROLET', 'CHEVY', 'NISSAN', 'HYUNDAI', 'KIA',
      'BMW', 'MERCEDES', 'AUDI', 'LEXUS', 'ACURA', 'INFINITI', 'SUBARU', 'MAZDA',
      'VOLKSWAGEN', 'VW', 'JEEP', 'DODGE', 'RAM', 'CHRYSLER', 'BUICK', 'GMC',
      'CADILLAC', 'LINCOLN', 'TESLA', 'VOLVO', 'PORSCHE', 'JAGUAR', 'LAND ROVER',
      'MITSUBISHI', 'SUZUKI', 'FIAT', 'ALFA ROMEO', 'MINI', 'GENESIS', 'RIVIAN'
    ];
    for (const pattern of makePatterns) {
      const regex = new RegExp(`\\b${pattern}\\b`, 'i');
      if (regex.test(cleanLine)) {
        make = pattern.charAt(0) + pattern.slice(1).toLowerCase();
        break;
      }
    }
  }

  // Clean up make/model (remove non-printable chars)
  if (make) make = make.replace(/[^\x20-\x7E]/g, '').trim() || undefined;
  if (model) model = model.replace(/[^\x20-\x7E]/g, '').trim() || undefined;

  return { vin, year, make, model, usage: undefined, coverages: [] };
}

/**
 * Parse a driver record (5DRV).
 * IVANS format has a complex name field with type prefix and split first/last names.
 * Uses fixed positions with pattern-based fallbacks for carrier variations.
 */
function parseDriver(line: string): AL3Driver | null {
  // Extract raw name area (positions 39-97: first name + last name)
  let rawName = extractField(line, DRV_FIELDS.NAME);
  if (!rawName) return null;

  // Clean non-printable characters and collapse whitespace
  rawName = rawName.replace(/[^\x20-\x7E]/g, ' ').replace(/\s+/g, ' ').trim();
  if (!rawName) return null;

  // Parse DOB — try multiple strategies with pattern fallback
  let dateOfBirth: string | undefined;

  // Strategy 1: YYYYMMDD at fixed position
  const dobFull = extractField(line, DRV_FIELDS.DOB_FULL);
  if (dobFull && /^\d{8}$/.test(dobFull)) {
    dateOfBirth = parseAL3Date(dobFull);
  }

  // Strategy 2: YYMMDD at fixed position
  if (!dateOfBirth) {
    const dobRaw = extractField(line, DRV_FIELDS.DOB);
    if (dobRaw && /^\d{6}$/.test(dobRaw)) {
      const yy = parseInt(dobRaw.substring(0, 2), 10);
      const mm = dobRaw.substring(2, 4);
      const dd = dobRaw.substring(4, 6);
      const yyyy = yy > 50 ? 1900 + yy : 2000 + yy;
      dateOfBirth = parseAL3Date(`${yyyy}${mm}${dd}`);
    }
  }

  // Strategy 3: UNIVERSAL FALLBACK - scan for date patterns anywhere in line
  if (!dateOfBirth) {
    // Look for YYYYMMDD pattern (1920-2010 birth years for drivers)
    const dobMatch = line.match(/\b(19[2-9]\d|200\d|201\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\b/);
    if (dobMatch) {
      dateOfBirth = parseAL3Date(dobMatch[0]);
    }
  }

  return {
    name: rawName,
    dateOfBirth,
    licenseNumber: extractField(line, DRV_FIELDS.LICENSE_NUMBER) || undefined,
    licenseState: extractField(line, DRV_FIELDS.LICENSE_STATE) || undefined,
    relationship: undefined,
  };
}

/**
 * Parse a 6SDV supplementary driver record (commercial auto).
 * Format: 6SDV256 D ... driver_num + flags + P + FIRSTNAME + LASTNAME + DOB
 */
function parseSupplementaryDriver(line: string): AL3Driver | null {
  if (line.length < 80) return null;

  // Find name region — look for capitalized name parts after the header
  // 6SDV format puts first name ~38 chars in, last name ~63 chars in
  const content = line.substring(30);

  // Extract first name (positions 38-62 relative to line start = 8-32 in content)
  const firstName = content.substring(8, 35).replace(/[^\x20-\x7E]/g, ' ').trim();
  // Extract last name (positions 63-87 = 33-57 in content)
  const lastName = content.substring(33, 60).replace(/[^\x20-\x7E]/g, ' ').trim();

  if (!firstName && !lastName) return null;

  const name = [firstName, lastName].filter(Boolean).join(' ');
  if (!name) return null;

  // Extract DOB — look for YYMMDD or YYYYMMDD pattern
  let dateOfBirth: string | undefined;

  // Look for YYYYMMDD pattern (1920-2010 birth years)
  const dobMatch = line.match(/\b(19[2-9]\d|200\d|201\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\b/);
  if (dobMatch) {
    dateOfBirth = parseAL3Date(dobMatch[0]);
  } else {
    // Try YYMMDD at end of line
    const endDigits = line.substring(line.length - 20).match(/(\d{6})/);
    if (endDigits) {
      const yy = parseInt(endDigits[1].substring(0, 2), 10);
      const mm = endDigits[1].substring(2, 4);
      const dd = endDigits[1].substring(4, 6);
      const yyyy = yy > 50 ? 1900 + yy : 2000 + yy;
      dateOfBirth = parseAL3Date(`${yyyy}${mm}${dd}`);
    }
  }

  return {
    name,
    dateOfBirth,
    licenseNumber: undefined,
    licenseState: undefined,
    relationship: undefined,
  };
}

/**
 * Parse a 5CAR commercial vehicle record.
 * Format: 5CAR418 C ... vehicle_num + flags + YEAR + MAKE + MODEL + VIN
 */
function parseCommercialVehicle(line: string): AL3Vehicle {
  const content = line.substring(30);

  // Extract year (4 digits - may follow ???? markers without word boundary)
  let year: number | undefined;
  const yearMatch = content.match(/(19[89]\d|20[0-2]\d)/);
  if (yearMatch) {
    year = parseInt(yearMatch[1], 10);
  }

  // Extract VIN (17 alphanumeric chars pattern)
  let vin: string | undefined;
  const vinMatch = line.match(/[A-HJ-NPR-Z0-9]{17}/i);
  if (vinMatch) {
    vin = vinMatch[0].toUpperCase();
  }

  // Extract make and model — typically after year, before VIN
  let make = '';
  let model = '';

  if (yearMatch) {
    const afterYear = content.substring(content.indexOf(yearMatch[1]) + 4);
    // Make is first word, model is remaining words before VIN
    const parts = afterYear.replace(/[^\x20-\x7E]/g, ' ').trim().split(/\s+/);
    if (parts.length > 0) {
      make = parts[0];
      // Model is next parts until we hit the VIN or type code
      const modelParts: string[] = [];
      for (let i = 1; i < parts.length && i < 5; i++) {
        if (parts[i].length >= 17 || /^[A-Z]$/.test(parts[i])) break; // Stop at VIN or type code
        modelParts.push(parts[i]);
      }
      model = modelParts.join(' ');
    }
  }

  return {
    vin,
    year,
    make,
    model,
    usage: undefined,
    coverages: [],
  };
}

/**
 * Parse a location record (5LOC) — generic fallback.
 */
function parseLocation(line: string): AL3Location | null {
  const content = line.substring(4).trim();
  if (!content) return null;

  return {
    address: content.substring(0, 60).trim() || undefined,
    city: content.substring(60, 90).trim() || undefined,
    state: content.substring(90, 92).trim() || undefined,
    zip: content.substring(92, 102).trim() || undefined,
  };
}

/**
 * Parse a 5LAG location address record using reference field positions.
 */
function parseLAGLocation(line: string): AL3Location | null {
  if (line.length < 110) return null;

  // LAG has a location number at 24-28, but Progressive offsets may push data forward
  // Read both number and address; if address starts with digits, it might be the number
  let locNumber = extractField(line, LAG_FIELDS.LOCATION_NUMBER).replace(/\?+/g, '').trim();
  let address = extractField(line, LAG_FIELDS.ADDRESS)
    .replace(/\?+/g, ' ').replace(/\s+/g, ' ').trim();

  // If location number ran into address, extract it
  if (!locNumber && address) {
    const numMatch = address.match(/^(\d{4})(.*)/);
    if (numMatch) {
      locNumber = numMatch[1];
      address = numMatch[2].trim();
    }
  }

  const city = extractField(line, LAG_FIELDS.CITY)
    .replace(/^\?+/, '').replace(/\?+/g, ' ').trim();
  const state = extractField(line, LAG_FIELDS.STATE).replace(/\?+/g, '').trim();
  const zip = extractField(line, LAG_FIELDS.ZIP).replace(/\?+/g, '').trim();

  if (!address && !city) return null;

  return {
    number: locNumber || undefined,
    address: address || undefined,
    city: city || undefined,
    state: (state && state.length === 2) ? state : undefined,
    zip: (zip && /^\d{5}/.test(zip)) ? zip.substring(0, 5) : undefined,
  };
}

/**
 * Parse an Allstate EDIFACT-format 9BIS address record.
 * Segments are 0xFA-delimited with pattern-matched fields.
 */
function parseAllstateAddress(line: string): { location: AL3Location; phone?: string } | null {
  // Split on 0xFA and process segments — look for address data
  // In 5BIS lines, address data comes after the 9BIS header boundary
  // In standalone 9BIS lines, address data is in the first few segments
  const parts: string[] = [];
  let start = 0;
  for (let i = 0; i < line.length; i++) {
    if (line.charCodeAt(i) === 0xFA) {
      parts.push(line.substring(start, i));
      start = i + 1;
    }
  }
  parts.push(line.substring(start));

  // Clean each part: strip non-printable chars, strip 2-char hex tag, strip ? filler
  // Track whether we've passed the address section boundary (9BIS header or address-like data)
  const cleanParts: string[] = [];
  let foundAddressSection = false;
  const gc = line.substring(0, 4);

  for (let i = 1; i < parts.length; i++) { // Skip first (REF) part
    let d = parts[i].replace(/[\x00-\x1F\x7F-\xFF]/g, '');
    // Strip 2-char hex tag
    const tagMatch = d.match(/^[0-9A-Fa-f]{2}\s?(.*)/);
    if (tagMatch) d = tagMatch[1];
    d = d.replace(/\?+/g, '').trim();
    if (!d) continue;

    // For 5BIS lines: skip segments until we hit a 9BIS header or address-like data
    if (gc === '5BIS' && !foundAddressSection) {
      if (/9BIS\d{3}/.test(d)) {
        foundAddressSection = true;
        continue; // Skip the header itself
      }
      // Also detect address start: segment with digits + letters (street address)
      if (/\d/.test(d) && /[a-zA-Z]/.test(d) && d.length > 5 && !/^\d[A-Z]{3}/.test(d)) {
        foundAddressSection = true;
        cleanParts.push(d);
      }
      continue;
    }

    // For standalone 9BIS, start parsing immediately
    if (gc === '9BIS') foundAddressSection = true;

    cleanParts.push(d);
  }

  let address: string | undefined;
  let city: string | undefined;
  let state: string | undefined;
  let zip: string | undefined;
  let phone: string | undefined;

  for (const d of cleanParts) {
    // Skip record headers (e.g., "5ISI203 B B200015BISB10001")
    if (/^\d[A-Z]{3}\d{3}/.test(d)) break; // Stop at next embedded record
    // Skip long numeric/code strings
    if (/^\d{8,}/.test(d) && !/^\d{10}$/.test(d)) continue;

    // State+ZIP: 2 uppercase letters followed by 5 digits (e.g., "AL35033", "AL352156718")
    if (!state && /^[A-Z]{2}\d{5}/.test(d)) {
      state = d.substring(0, 2);
      zip = d.substring(2, 7);
      // Check for embedded phone: "AL352156718" → zip=35215, phone=6718 (partial)
      // "AL3509378229065" → zip=35093, phone area embedded
      if (d.length >= 12) {
        const phoneCandidate = d.substring(7);
        if (/^\d{7,10}$/.test(phoneCandidate)) phone = phoneCandidate;
      }
      continue;
    }

    // Phone: exactly 10 digits
    if (!phone && /^\d{10}$/.test(d)) {
      phone = d;
      continue;
    }

    // Address: contains both digits and letters (street address pattern)
    if (!address && /\d/.test(d) && /[a-zA-Z]/.test(d) && d.length > 5) {
      address = d;
      continue;
    }

    // City: alphabetic, 3-30 chars
    if (!city && /^[A-Za-z][A-Za-z .'\-]{2,29}$/.test(d)) {
      city = d;
      continue;
    }
  }

  if (!address && !city && !state) return null;

  return {
    location: {
      address: address || undefined,
      city: city || undefined,
      state: state || undefined,
      zip: zip || undefined,
    },
    phone,
  };
}

/**
 * Parse a 9BIS insured address continuation record.
 * Two variants: long (343 bytes) and short (168 bytes, Safeco).
 */
function parseBISAddress(line: string): AL3Location | null {
  if (line.length < 100) return null;

  // Use short fields for shorter records (Safeco 168-byte variant)
  const fields = line.length > 200 ? BIS_ADDRESS_FIELDS : BIS_ADDRESS_FIELDS_SHORT;

  const address = extractField(line, fields.ADDRESS_1)
    .replace(/\?+/g, ' ').replace(/\s+/g, ' ').trim();

  let city: string;
  if ('CITY' in fields) {
    city = extractField(line, fields.CITY)
      .replace(/^\?+/, '').replace(/\?+/g, ' ').trim();
  } else {
    city = '';
  }

  const state = extractField(line, fields.STATE).replace(/\?+/g, '').trim();
  const zip = extractField(line, fields.ZIP).replace(/\?+/g, '').trim();

  if (!address && !city && !state) return null;

  return {
    address: address || undefined,
    city: city || undefined,
    state: (state && state.length === 2) ? state : undefined,
    zip: (zip && /^\d{5}/.test(zip)) ? zip.substring(0, 5) : undefined,
  };
}

/**
 * Parse a 5AOI mortgagee/lienholder record.
 */
function parseMortgagee(line: string): AL3Mortgagee | null {
  if (line.length < 72) return null;

  // EDIFACT (Allstate): extract from 0xFA-delimited segments
  if (isEDIFACTFormat(line)) {
    const segments = parseEDIFACTSegments(line);
    let interestType: string | undefined;
    let name: string | undefined;
    let loanNumber: string | undefined;

    for (const seg of segments) {
      if (seg.tag === 'REF') continue;
      // Interest type: 2-char uppercase (LH, MS, CN)
      if (!interestType && /^[A-Z]{2}$/.test(seg.data)) {
        interestType = seg.data;
        continue;
      }
      // Loan number: numeric segment
      if (!loanNumber && /^\d{5,}$/.test(seg.data)) {
        loanNumber = seg.data;
        continue;
      }
      // Name: alpha segment with 3+ chars
      if (!name && /[a-zA-Z]{3,}/.test(seg.data) && !/^\d+$/.test(seg.data)) {
        let n = seg.data;
        // Strip entity type prefix (C/P)
        if (/^[CP][A-Z]/.test(n)) n = n.substring(1);
        name = n.trim();
        continue;
      }
    }

    if (!name) return null;
    return {
      interestType,
      name,
      loanNumber,
    };
  }

  let interestType = extractField(line, AOI_FIELDS.INTEREST_TYPE).replace(/\?+/g, '').trim();
  let rawName = extractField(line, AOI_FIELDS.NAME)
    .replace(/[\x00-\x1F\x7F-\xFF]/g, ' ')
    .replace(/\?+/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  if (!rawName) return null;

  // Strip prefix residue: sequence + interest type + entity type that bleeds into name field
  // Pattern: "1LH01 CFord Motor Credit" → extract interest type from prefix, then strip it
  const prefixMatch = rawName.match(/^(\d+)([A-Z]{2})(\d+)\s*([CP])(.*)/);
  if (prefixMatch) {
    if (!interestType) interestType = prefixMatch[2]; // LH, MS, CN, etc.
    rawName = prefixMatch[5].trim();
  }

  if (!rawName) return null;

  let loanNumber: string | undefined;
  if (line.length > 141) {
    loanNumber = extractField(line, AOI_FIELDS.LOAN_NUMBER).replace(/\?+/g, '').trim() || undefined;
  }

  return {
    interestType: interestType || undefined,
    name: rawName,
    loanNumber,
  };
}

/**
 * Parse a discount record (5DSC).
 */
function parseDiscount(line: string): AL3Discount | null {
  const code = extractField(line, DSC_FIELDS.DISCOUNT_CODE);
  if (!code) return null;

  return {
    code,
    description: extractField(line, DSC_FIELDS.DESCRIPTION) || undefined,
    amount: parseAL3Number(extractField(line, DSC_FIELDS.AMOUNT)),
    percent: parseAL3Number(extractField(line, DSC_FIELDS.PERCENT)),
  };
}

/**
 * Parse a claim record (5CLM).
 */
function parseClaim(line: string): AL3Claim | null {
  const claimNumber = extractField(line, CLM_FIELDS.CLAIM_NUMBER);
  const claimType = extractField(line, CLM_FIELDS.CLAIM_TYPE);
  if (!claimNumber && !claimType) return null;

  return {
    claimNumber: claimNumber || undefined,
    claimDate: parseAL3Date(extractField(line, CLM_FIELDS.CLAIM_DATE)),
    claimType: claimType || undefined,
    amount: parseAL3Number(extractField(line, CLM_FIELDS.AMOUNT)),
    status: extractField(line, CLM_FIELDS.STATUS) || undefined,
  };
}

/**
 * Parse an endorsement record (5END).
 */
function parseEndorsement(line: string): AL3Endorsement | null {
  const code = extractField(line, END_FIELDS.ENDORSEMENT_CODE);
  if (!code) return null;

  return {
    code,
    description: extractField(line, END_FIELDS.DESCRIPTION) || undefined,
    effectiveDate: parseAL3Date(extractField(line, END_FIELDS.EFFECTIVE_DATE)),
    premium: parseAL3Number(extractField(line, END_FIELDS.PREMIUM)),
  };
}


// ============================================================================
// FILE: src/lib/al3/filter.ts
// ============================================================================

/**
 * AL3 Filter & Deduplication
 * ==========================
 * Filters AL3 transactions to only renewal types and deduplicates.
 */

import type { AL3ParsedTransaction, AL3TransactionHeader } from '@/types/renewal.types';
import { DEFAULT_RENEWAL_TRANSACTION_TYPES, TRG_FIELDS, LOB_CODES } from './constants';
import { parseAL3Date, splitAL3Records } from './parser';

/**
 * Quick header scan - extracts transaction headers without full parsing.
 * Faster than full parse when you just need to filter.
 */
export function extractTransactionHeaders(content: string): AL3TransactionHeader[] {
  const lines = splitAL3Records(content);
  const headers: AL3TransactionHeader[] = [];

  for (const line of lines) {
    if (line.length >= 4 && line.substring(0, 4) === '2TRG') {
      const transactionType = line.substring(TRG_FIELDS.TRANSACTION_TYPE.start, TRG_FIELDS.TRANSACTION_TYPE.end).trim();
      const carrierCode = line.substring(TRG_FIELDS.COMPANY_CODE.start, TRG_FIELDS.COMPANY_CODE.end).trim();
      const policyNumber = line.substring(TRG_FIELDS.POLICY_NUMBER.start, TRG_FIELDS.POLICY_NUMBER.end).trim();
      const effectiveDateRaw = line.substring(TRG_FIELDS.EFFECTIVE_DATE.start, TRG_FIELDS.EFFECTIVE_DATE.end).trim();
      const expirationDateRaw = line.substring(TRG_FIELDS.EXPIRATION_DATE.start, TRG_FIELDS.EXPIRATION_DATE.end).trim();
      const lobCode = line.substring(TRG_FIELDS.LOB_CODE.start, TRG_FIELDS.LOB_CODE.end).trim();

      headers.push({
        transactionType,
        policyNumber,
        carrierCode,
        lineOfBusiness: LOB_CODES[lobCode] || lobCode || undefined,
        effectiveDate: parseAL3Date(effectiveDateRaw),
        expirationDate: parseAL3Date(expirationDateRaw),
      });
    }
  }

  return headers;
}

/**
 * Filter transactions to only renewal types.
 * Uses carrier-specific renewal types if provided, otherwise defaults.
 */
export function filterRenewalTransactions(
  transactions: AL3ParsedTransaction[],
  carrierRenewalTypes?: string[],
  defaults: string[] = DEFAULT_RENEWAL_TRANSACTION_TYPES
): AL3ParsedTransaction[] {
  const renewalTypes = new Set(
    (carrierRenewalTypes && carrierRenewalTypes.length > 0 ? carrierRenewalTypes : defaults)
      .map((t) => t.toUpperCase())
  );

  return transactions.filter((t) =>
    renewalTypes.has(t.header.transactionType.toUpperCase())
  );
}

/**
 * Partition transactions into renewals and non-renewals.
 * Returns both arrays so non-renewals can be archived.
 */
export function partitionTransactions(
  transactions: AL3ParsedTransaction[],
  carrierRenewalTypes?: string[],
  defaults: string[] = DEFAULT_RENEWAL_TRANSACTION_TYPES
): { renewals: AL3ParsedTransaction[]; nonRenewals: AL3ParsedTransaction[] } {
  const renewalTypes = new Set(
    (carrierRenewalTypes && carrierRenewalTypes.length > 0 ? carrierRenewalTypes : defaults)
      .map((t) => t.toUpperCase())
  );

  const renewals: AL3ParsedTransaction[] = [];
  const nonRenewals: AL3ParsedTransaction[] = [];

  for (const t of transactions) {
    if (renewalTypes.has(t.header.transactionType.toUpperCase())) {
      renewals.push(t);
    } else {
      nonRenewals.push(t);
    }
  }

  return { renewals, nonRenewals };
}

/**
 * Deduplicate renewals by carrier+policy+effectiveDate.
 * Keeps the most recent (last in file order, which is typically most recent).
 */
export function deduplicateRenewals(
  renewals: AL3ParsedTransaction[]
): { unique: AL3ParsedTransaction[]; duplicatesRemoved: number } {
  const seen = new Map<string, AL3ParsedTransaction>();

  for (const renewal of renewals) {
    const key = [
      renewal.header.carrierCode,
      renewal.header.policyNumber,
      renewal.header.effectiveDate || '',
    ].join('|');

    // Always overwrite - later entries are more recent
    seen.set(key, renewal);
  }

  const unique = Array.from(seen.values());
  const duplicatesRemoved = renewals.length - unique.length;

  return { unique, duplicatesRemoved };
}


// ============================================================================
// FILE: src/lib/al3/snapshot-builder.ts
// ============================================================================

/**
 * Snapshot Builder
 * ================
 * Converts parsed AL3 transactions into canonical RenewalSnapshot format.
 */

import type {
  AL3ParsedTransaction,
  RenewalSnapshot,
  CanonicalCoverage,
  CanonicalVehicle,
  CanonicalDriver,
  CanonicalDiscount,
  CanonicalEndorsement,
  CanonicalClaim,
} from '@/types/renewal.types';
import { COVERAGE_CODE_MAP, DISCOUNT_COVERAGE_TYPES, VEHICLE_LEVEL_COVERAGE_TYPES } from './constants';
import { parseSplitLimit } from './parser';

/**
 * Normalize a carrier-specific coverage code to a canonical type.
 */
export function normalizeCoverageType(
  code: string,
  carrierOverrides?: Record<string, string>
): string {
  const upperCode = code.toUpperCase().trim();

  // Check carrier-specific overrides first
  if (carrierOverrides?.[upperCode]) {
    return carrierOverrides[upperCode];
  }

  // Check standard map
  if (COVERAGE_CODE_MAP[upperCode]) {
    return COVERAGE_CODE_MAP[upperCode];
  }

  // Return as-is (snake_case normalized)
  return upperCode.toLowerCase().replace(/[^a-z0-9]+/g, '_');
}

/**
 * Build a canonical RenewalSnapshot from a parsed AL3 transaction.
 */
export function buildRenewalSnapshot(
  transaction: AL3ParsedTransaction,
  carrierOverrides?: Record<string, string>
): RenewalSnapshot {
  // Normalize coverages — re-parse limitAmount/deductibleAmount with split-limit awareness
  // parseSplitLimit returns undefined for 0 values (AL3 "00" filler fields)
  const coverages: CanonicalCoverage[] = transaction.coverages.map((cov) => ({
    type: normalizeCoverageType(cov.code, carrierOverrides),
    description: cov.description || cov.code,
    limit: cov.limit,
    limitAmount: parseSplitLimit(cov.limit || '') ?? cov.limitAmount,
    deductible: cov.deductible,
    deductibleAmount: parseSplitLimit(cov.deductible || '') ?? (cov.deductibleAmount || undefined),
    premium: cov.premium,
  }));

  // Normalize vehicles (with their coverages)
  const vehicles: CanonicalVehicle[] = transaction.vehicles.map((veh) => ({
    vin: veh.vin,
    year: veh.year,
    make: veh.make,
    model: veh.model,
    usage: veh.usage,
    coverages: veh.coverages.map((cov) => ({
      type: normalizeCoverageType(cov.code, carrierOverrides),
      description: cov.description || cov.code,
      limit: cov.limit,
      limitAmount: parseSplitLimit(cov.limit || '') ?? cov.limitAmount,
      deductible: cov.deductible,
      deductibleAmount: parseSplitLimit(cov.deductible || '') ?? (cov.deductibleAmount || undefined),
      premium: cov.premium,
    })),
  }));

  // Normalize drivers
  const drivers: CanonicalDriver[] = transaction.drivers.map((drv) => ({
    name: drv.name,
    dateOfBirth: drv.dateOfBirth,
    licenseNumber: drv.licenseNumber,
    licenseState: drv.licenseState,
    relationship: drv.relationship,
    isExcluded: drv.isExcluded,
  }));

  // Flatten ALL coverages from vehicles into policy coverages array
  // This enables apples-to-apples comparison with HawkSoft baseline (which is flat)
  // Premium is summed across vehicles for same coverage type
  if (vehicles.length > 0) {
    // Build a map of existing policy-level coverages for dedup
    const seen = new Map<string, CanonicalCoverage>();
    for (const cov of coverages) {
      if (cov.type) seen.set(cov.type, cov);
    }

    // Add/merge vehicle coverages
    for (const veh of vehicles) {
      for (const cov of veh.coverages) {
        if (!cov.type) continue;

        const existing = seen.get(cov.type);
        if (existing) {
          // Sum premiums across vehicles for same coverage type
          if (cov.premium != null) {
            existing.premium = (existing.premium ?? 0) + cov.premium;
          }
        } else {
          seen.set(cov.type, { ...cov });
        }
      }
    }

    // Replace coverages with flattened set
    coverages.length = 0;
    coverages.push(...seen.values());
  }

  // Partition discount-type coverages into discounts array
  const realCoverages: CanonicalCoverage[] = [];
  const discountCoverages: CanonicalDiscount[] = [];
  for (const cov of coverages) {
    if (DISCOUNT_COVERAGE_TYPES.has(cov.type)) {
      discountCoverages.push({
        code: cov.type,
        description: cov.description || cov.type,
        amount: cov.premium,
      });
    } else {
      realCoverages.push(cov);
    }
  }
  // Replace coverages with only real coverages
  coverages.length = 0;
  coverages.push(...realCoverages);

  // Calculate total premium
  // PRIMARY: Use 5BPI record premium (authoritative policy-level)
  // FALLBACK: Sum coverage premiums if 5BPI not available
  let totalPremium: number | undefined = transaction.totalPremium;

  if (!totalPremium) {
    // Fallback: sum from coverage-level premiums.
    // Vehicle coverages are already flattened into the policy-level coverages array above,
    // so we only need to sum from coverages (not vehicles) to avoid double-counting.
    const allCoveragePremiums = coverages
      .filter((c) => c.premium != null)
      .map((c) => c.premium!);
    if (allCoveragePremiums.length > 0) {
      totalPremium = allCoveragePremiums.reduce((sum, p) => sum + p, 0);
    }
  }

  // Map structured endorsement records to canonical format
  const endorsements: CanonicalEndorsement[] = transaction.endorsementRecords.map((e) => ({
    code: e.code,
    description: e.description || e.code,
    effectiveDate: e.effectiveDate,
    premium: e.premium,
  }));

  // Fallback: extract endorsements from remarks if no structured records found
  if (endorsements.length === 0) {
    for (const remark of transaction.remarks) {
      const lower = remark.toLowerCase();
      if (lower.includes('endorsement') || lower.includes('rider')) {
        endorsements.push({ code: 'RMK', description: remark });
      }
    }
  }

  // Map structured discount records to canonical format
  const discounts: CanonicalDiscount[] = transaction.discountRecords.map((d) => ({
    code: d.code,
    description: d.description || d.code,
    amount: d.amount,
    percent: d.percent,
  }));

  // Add discount-type coverages partitioned from the coverages array
  discounts.push(...discountCoverages);

  // Fallback: extract discounts from remarks if no structured records found
  if (discounts.length === 0) {
    for (const remark of transaction.remarks) {
      const lower = remark.toLowerCase();
      if (lower.includes('discount') || lower.includes('credit')) {
        discounts.push({ code: 'RMK', description: remark });
      }
    }
  }

  // Map claims
  const claims: CanonicalClaim[] = transaction.claims.map((c) => ({
    claimNumber: c.claimNumber,
    claimDate: c.claimDate,
    claimType: c.claimType,
    amount: c.amount,
    status: c.status,
  }));

  return {
    insuredName: transaction.header.insuredName,
    insuredAddress: transaction.insuredAddress?.address,
    insuredCity: transaction.insuredAddress?.city,
    insuredState: transaction.insuredAddress?.state,
    insuredZip: transaction.insuredAddress?.zip,
    insuredEmail: transaction.insuredEmail,
    insuredPhone: transaction.insuredPhone,
    premium: totalPremium,
    coverages,
    vehicles,
    drivers,
    endorsements,
    discounts,
    claims,
    parseConfidence: transaction.parseConfidence,
    parsedAt: new Date().toISOString(),
    sourceFileName: undefined,
  };
}


// ============================================================================
// FILE: src/lib/al3/baseline-builder.ts
// ============================================================================

/**
 * Baseline Builder
 * ================
 * Builds a BaselineSnapshot from HawkSoft policy data.
 * Checks local DB first, falls back to HawkSoft API.
 */

import { db } from '@/db';
import { policies, vehicles, drivers, customers, properties, policyNotices } from '@/db/schema';
import { eq, and, like, or, sql } from 'drizzle-orm';
import type {
  BaselineSnapshot,
  CanonicalCoverage,
  CanonicalVehicle,
  CanonicalDriver,
  CanonicalDiscount,
  CanonicalClaim,
  PropertyContext,
} from '@/types/renewal.types';
import { COVERAGE_CODE_MAP, DISCOUNT_COVERAGE_TYPES } from './constants';
import { parseSplitLimit } from './parser';
import { getHawkSoftClient } from '@/lib/api/hawksoft';

// =============================================================================
// POLICY NUMBER NORMALIZATION
// =============================================================================

/**
 * Strip term suffix from policy numbers.
 * Some carriers (National General, Orion180, etc.) append -1, -2, -3 etc.
 * to indicate which term a policy is on. The base policy number is the same
 * across terms, so we strip the suffix for matching purposes.
 *
 * Examples:
 *   "OSIH3AL_01436810-3" → "OSIH3AL_01436810"
 *   "ABC123-1"           → "ABC123"
 *   "A7992503360"        → "A7992503360" (no suffix, unchanged)
 */
export function stripTermSuffix(policyNumber: string): string {
  return policyNumber.replace(/-\d{1,2}$/, '');
}

/**
 * Check if a policy number has a term suffix (e.g., -1, -2, -3).
 */
export function hasTermSuffix(policyNumber: string): boolean {
  return /-\d{1,2}$/.test(policyNumber);
}

// =============================================================================
// LOCAL POLICY LOOKUP
// =============================================================================

/**
 * Find a policy in the local database by policy number.
 * If exact match fails and the policy number has a term suffix (e.g., -3),
 * tries matching by the base policy number (stripping the suffix) using a
 * LIKE query to find prior terms (e.g., -2, -1, or no suffix).
 */
export async function findLocalPolicy(
  tenantId: string,
  policyNumber: string
): Promise<{ policyId: string; customerId: string } | null> {
  // Try exact match first
  const [exactMatch] = await db
    .select({
      id: policies.id,
      customerId: policies.customerId,
    })
    .from(policies)
    .where(
      and(
        eq(policies.tenantId, tenantId),
        eq(policies.policyNumber, policyNumber)
      )
    )
    .limit(1);

  if (exactMatch) {
    return { policyId: exactMatch.id, customerId: exactMatch.customerId };
  }

  // If the policy number has a term suffix, try matching by base number
  if (hasTermSuffix(policyNumber)) {
    const baseNumber = stripTermSuffix(policyNumber);
    console.log(`[Baseline] Exact match failed for "${policyNumber}", trying base number "${baseNumber}"`);

    const [baseMatch] = await db
      .select({
        id: policies.id,
        customerId: policies.customerId,
        policyNumber: policies.policyNumber,
      })
      .from(policies)
      .where(
        and(
          eq(policies.tenantId, tenantId),
          like(policies.policyNumber, `${baseNumber}%`)
        )
      )
      .limit(1);

    if (baseMatch) {
      console.log(`[Baseline] Matched "${policyNumber}" → existing policy "${baseMatch.policyNumber}"`);
      return { policyId: baseMatch.id, customerId: baseMatch.customerId };
    }
  }

  return null;
}

// =============================================================================
// HAWKSOFT NORMALIZATION
// =============================================================================

// HawkSoft placeholder codes that aren't real coverages (notes, references, etc.)
const HAWKSOFT_PLACEHOLDER_CODES = new Set([
  'CHECKDEC',    // "See Decl. Page for Additional Premiums"
  'SEEDEC',      // "See Declaration Page"
  'NOTE',        // General note
  'REMARK',      // Remark
  'MEMO',        // Memo
]);

/**
 * Normalize HawkSoft coverage format to canonical.
 * Handles BOTH formats:
 *   - HawkSoft API: { code, description, limits, deductibles, premium (string) }
 *   - Local DB:     { type, limit, deductible, premium (number) }
 */
export function normalizeHawkSoftCoverages(
  hsCoverages: Array<Record<string, any>> | null | undefined
): CanonicalCoverage[] {
  if (!hsCoverages || !Array.isArray(hsCoverages)) return [];

  return hsCoverages
    .filter((cov) => {
      // Accept both DB format (type) and HawkSoft format (code)
      const code = (cov.code || cov.type || '').toUpperCase().trim();
      // Filter out placeholder codes that aren't real coverages
      return !HAWKSOFT_PLACEHOLDER_CODES.has(code);
    })
    .map((cov) => {
      // Accept both DB format (type/limit/deductible) and HawkSoft format (code/limits/deductibles)
      const code = (cov.code || cov.type || '').toUpperCase().trim();
      const canonicalType = COVERAGE_CODE_MAP[code] || code.toLowerCase().replace(/[^a-z0-9]+/g, '_');
      const limitStr = cov.limits || cov.limit || '';
      const dedStr = cov.deductibles || cov.deductible || '';
      const premiumVal = typeof cov.premium === 'string' ? parseFloat(cov.premium) : (cov.premium ?? undefined);

      return {
        type: canonicalType || '',
        description: cov.description || '',
        limit: limitStr || undefined,
        limitAmount: parseSplitLimit(limitStr),
        deductible: dedStr || undefined,
        deductibleAmount: parseSplitLimit(dedStr),
        premium: isNaN(premiumVal as number) ? undefined : premiumVal,
      };
    });
}

/**
 * Normalize HawkSoft vehicle data to canonical.
 */
export function normalizeHawkSoftVehicles(
  hsVehicles: Array<{
    vin?: string | null;
    year?: number | null;
    make?: string | null;
    model?: string | null;
    use?: string | null;
    coverages?: any;
  }>
): CanonicalVehicle[] {
  return hsVehicles.map((v) => ({
    vin: v.vin || undefined,
    year: v.year || undefined,
    make: v.make || undefined,
    model: v.model || undefined,
    usage: v.use || undefined,
    coverages: normalizeHawkSoftCoverages(v.coverages),
  }));
}

/**
 * Normalize HawkSoft driver data to canonical.
 */
function normalizeHawkSoftDrivers(
  hsDrivers: Array<{
    firstName: string;
    lastName: string;
    dateOfBirth?: Date | null;
    licenseNumber?: string | null;
    licenseState?: string | null;
    relationship?: string | null;
    isExcluded?: boolean | null;
  }>
): CanonicalDriver[] {
  return hsDrivers.map((d) => ({
    name: `${d.firstName} ${d.lastName}`.trim(),
    dateOfBirth: d.dateOfBirth ? d.dateOfBirth.toISOString().split('T')[0] : undefined,
    licenseNumber: d.licenseNumber || undefined,
    licenseState: d.licenseState || undefined,
    relationship: d.relationship || undefined,
    isExcluded: d.isExcluded ?? undefined,
  }));
}

// =============================================================================
// MAIN BUILDER
// =============================================================================

/**
 * Check if the local policy data is stale (already updated to new term).
 * Returns true if the policy's effectiveDate matches or is after the renewal effective date.
 */
function isLocalPolicyStale(
  policyEffectiveDate: Date | null | undefined,
  renewalEffectiveDate?: string
): boolean {
  if (!renewalEffectiveDate || !policyEffectiveDate) return false;
  const policyEff = policyEffectiveDate.toISOString().split('T')[0];
  const renewalEff = renewalEffectiveDate.split('T')[0];
  return policyEff >= renewalEff;
}

/**
 * Reconstruct a BaselineSnapshot from a prior-term snapshot stored on the policy.
 */
function reconstructFromPriorTerm(
  priorTerm: Record<string, any>,
  propertyContext?: PropertyContext,
  claims?: CanonicalClaim[]
): BaselineSnapshot {
  const coverages = normalizeHawkSoftCoverages(priorTerm.coverages);

  const realCoverages: CanonicalCoverage[] = [];
  const discountCoverages: CanonicalDiscount[] = [];
  for (const cov of coverages) {
    if (DISCOUNT_COVERAGE_TYPES.has(cov.type)) {
      discountCoverages.push({
        code: cov.type,
        description: cov.description || cov.type,
        amount: cov.premium,
      });
    } else {
      realCoverages.push(cov);
    }
  }

  // Calculate premium from coverages, fall back to stored premium
  let calculatedPremium: number | undefined;
  const allCoveragePremiums = realCoverages.filter(c => c.premium != null).map(c => c.premium!);
  if (allCoveragePremiums.length > 0) {
    calculatedPremium = allCoveragePremiums.reduce((sum, p) => sum + p, 0);
  }
  const premium = calculatedPremium ?? (priorTerm.premium ? parseFloat(priorTerm.premium) : undefined);

  // Reconstruct vehicles (preserve their coverages from prior term)
  const priorVehicles: CanonicalVehicle[] = (priorTerm.vehicles || []).map((v: any) => ({
    vin: v.vin || undefined,
    year: v.year || undefined,
    make: v.make || undefined,
    model: v.model || undefined,
    usage: v.use || v.usage || undefined,
    coverages: Array.isArray(v.coverages) ? normalizeHawkSoftCoverages(v.coverages) : [],
  }));

  // Reconstruct drivers
  const priorDrivers: CanonicalDriver[] = (priorTerm.drivers || []).map((d: any) => ({
    name: `${d.firstName || ''} ${d.lastName || ''}`.trim(),
    dateOfBirth: d.dateOfBirth || undefined,
    licenseNumber: d.licenseNumber || undefined,
    licenseState: d.licenseState || undefined,
    relationship: d.relationship || undefined,
    isExcluded: d.isExcluded ?? undefined,
  }));

  return {
    premium,
    coverages: realCoverages,
    vehicles: priorVehicles,
    drivers: priorDrivers,
    endorsements: [],
    discounts: discountCoverages,
    claims: claims || [],
    propertyContext,
    policyEffectiveDate: priorTerm.effectiveDate,
    policyExpirationDate: priorTerm.expirationDate,
    fetchedAt: new Date().toISOString(),
    fetchSource: 'prior_term_snapshot',
  };
}

/**
 * Build a BaselineSnapshot for a policy.
 *
 * Priority chain:
 * 1. Local DB (now populated by enhanced sync with coverages/vehicles/drivers)
 * 2. Prior-term snapshot (if local data is stale — already updated to renewal term)
 * 3. HawkSoft API (last resort, may also be stale)
 */
export async function buildBaselineSnapshot(
  tenantId: string,
  policyNumber: string,
  _carrierName?: string,
  renewalEffectiveDate?: string
): Promise<{ snapshot: BaselineSnapshot; policyId: string; customerId: string } | null> {
  // Find local policy
  const localPolicy = await findLocalPolicy(tenantId, policyNumber);
  if (!localPolicy) {
    return null;
  }

  // Fetch policy with related data
  const [policy] = await db
    .select()
    .from(policies)
    .where(eq(policies.id, localPolicy.policyId))
    .limit(1);

  if (!policy) return null;

  // Fetch property context (used by all paths)
  let propertyContext: PropertyContext | undefined;
  const [prop] = await db
    .select({
      roofAge: properties.roofAge,
      roofType: properties.roofType,
      yearBuilt: properties.yearBuilt,
      constructionType: properties.constructionType,
    })
    .from(properties)
    .where(eq(properties.customerId, localPolicy.customerId))
    .limit(1);

  if (prop) {
    propertyContext = {
      roofAge: prop.roofAge ?? undefined,
      roofType: prop.roofType ?? undefined,
      yearBuilt: prop.yearBuilt ?? undefined,
      constructionType: prop.constructionType ?? undefined,
    };
  }

  // Fetch claims (used by all paths)
  const claimNotices = await db
    .select({
      claimNumber: policyNotices.claimNumber,
      claimDate: policyNotices.claimDate,
      claimStatus: policyNotices.claimStatus,
      description: policyNotices.description,
    })
    .from(policyNotices)
    .where(
      and(
        eq(policyNotices.policyId, policy.id),
        eq(policyNotices.noticeType, 'claim')
      )
    );

  const claims: CanonicalClaim[] = claimNotices.map((n) => ({
    claimNumber: n.claimNumber ?? undefined,
    claimDate: n.claimDate ?? undefined,
    claimType: n.description ?? undefined,
    status: n.claimStatus ?? undefined,
  }));

  // Check if local data is stale (already updated to renewal term)
  const stale = isLocalPolicyStale(policy.effectiveDate, renewalEffectiveDate);

  // If stale and we have a prior-term snapshot, use it
  if (stale && (policy as any).priorTermSnapshot) {
    console.log(`[Baseline] Using prior-term snapshot for ${policyNumber} (local data is stale)`);
    const snapshot = reconstructFromPriorTerm(
      (policy as any).priorTermSnapshot,
      propertyContext,
      claims
    );
    return { snapshot, policyId: localPolicy.policyId, customerId: localPolicy.customerId };
  }

  // Fetch vehicles and drivers from local DB
  let policyVehicles = await db
    .select()
    .from(vehicles)
    .where(eq(vehicles.policyId, policy.id));

  let policyDrivers = await db
    .select()
    .from(drivers)
    .where(eq(drivers.policyId, policy.id));

  let localCoverages = normalizeHawkSoftCoverages(policy.coverages as any);

  // Fill gaps from HawkSoft API — check each category independently
  let fetchSource: 'hawksoft_api' | 'local_cache' | 'prior_term_snapshot' = 'local_cache';
  let hsVehicles: CanonicalVehicle[] = [];
  let hsDrivers: CanonicalDriver[] = [];
  let hsCoverages: CanonicalCoverage[] = [];

  const needsVehicles = policyVehicles.length === 0;
  const needsDrivers = policyDrivers.length === 0;
  const needsCoverages = localCoverages.length === 0;

  if (needsVehicles || needsDrivers || needsCoverages) {
    const hsData = await fetchHawkSoftPolicyData(localPolicy.customerId, policyNumber);
    if (hsData) {
      if (needsVehicles) hsVehicles = hsData.vehicles;
      if (needsDrivers) hsDrivers = hsData.drivers;
      if (needsCoverages) hsCoverages = hsData.coverages;
      fetchSource = 'hawksoft_api';
    }
  }

  // Partition discount-type coverages into discounts array
  const allCoverages = localCoverages.length > 0 ? localCoverages : hsCoverages;
  const realCoverages: CanonicalCoverage[] = [];
  const discountCoverages: CanonicalDiscount[] = [];
  for (const cov of allCoverages) {
    if (DISCOUNT_COVERAGE_TYPES.has(cov.type)) {
      discountCoverages.push({
        code: cov.type,
        description: cov.description || cov.type,
        amount: cov.premium,
      });
    } else {
      realCoverages.push(cov);
    }
  }

  // Calculate premium from coverage premiums (more reliable than stored policy.premium
  // which may get overwritten when HawkSoft syncs new term data)
  let calculatedPremium: number | undefined;
  const allCoveragePremiums = realCoverages
    .filter(c => c.premium != null)
    .map(c => c.premium!);
  if (allCoveragePremiums.length > 0) {
    calculatedPremium = allCoveragePremiums.reduce((sum, p) => sum + p, 0);
  }
  // Fall back to stored policy premium if no coverage premiums
  const baselinePremium = calculatedPremium ?? (policy.premium ? parseFloat(policy.premium) : undefined);

  // Build snapshot — use HawkSoft API data if local was empty
  const snapshot: BaselineSnapshot = {
    premium: baselinePremium,
    coverages: realCoverages,
    vehicles: policyVehicles.length > 0 ? normalizeHawkSoftVehicles(policyVehicles) : hsVehicles,
    drivers: policyDrivers.length > 0 ? normalizeHawkSoftDrivers(policyDrivers) : hsDrivers,
    endorsements: [],
    discounts: discountCoverages,
    claims,
    propertyContext,
    // Capture policy term dates for stale baseline detection
    policyEffectiveDate: policy.effectiveDate?.toISOString().split('T')[0],
    policyExpirationDate: policy.expirationDate?.toISOString().split('T')[0],
    fetchedAt: new Date().toISOString(),
    fetchSource,
  };

  return {
    snapshot,
    policyId: localPolicy.policyId,
    customerId: localPolicy.customerId,
  };
}

/**
 * Fetch policy data from HawkSoft API for baseline enrichment.
 * Looks up the customer's HawkSoft client code, then fetches full policy data.
 */
async function fetchHawkSoftPolicyData(
  customerId: string,
  policyNumber: string
): Promise<{ vehicles: CanonicalVehicle[]; drivers: CanonicalDriver[]; coverages: CanonicalCoverage[] } | null> {
  try {
    // Get customer's HawkSoft client code
    const [customer] = await db
      .select({ hawksoftClientCode: customers.hawksoftClientCode })
      .from(customers)
      .where(eq(customers.id, customerId))
      .limit(1);

    if (!customer?.hawksoftClientCode) return null;

    const clientId = parseInt(customer.hawksoftClientCode, 10);
    if (isNaN(clientId)) return null;

    // Call HawkSoft API with policy expansions
    const api = getHawkSoftClient();
    const client = await api.getClient(clientId, ['policies'], ['policies.drivers', 'policies.autos', 'policies.coverages']);

    if (!client?.policies?.length) return null;

    // Find matching policy by number (exact match first, then base number)
    let matchingPolicy = client.policies.find((p: any) => p.policyNumber === policyNumber);
    if (!matchingPolicy && hasTermSuffix(policyNumber)) {
      const baseNumber = stripTermSuffix(policyNumber);
      matchingPolicy = client.policies.find((p: any) =>
        p.policyNumber && stripTermSuffix(p.policyNumber) === baseNumber
      );
    }
    if (!matchingPolicy) return null;

    // Normalize the HawkSoft data
    const hsVehicles = matchingPolicy.vehicles || matchingPolicy.autos || [];
    const hsDrivers = matchingPolicy.drivers || [];
    const hsCoverages = matchingPolicy.coverages || [];

    return {
      vehicles: hsVehicles.map((v: any) => ({
        vin: v.vin || undefined,
        year: v.year || undefined,
        make: v.make || undefined,
        model: v.model || undefined,
        usage: v.usage || v.use || undefined,
        coverages: normalizeHawkSoftCoverages(v.coverages),
      })),
      drivers: hsDrivers.map((d: any) => ({
        name: `${d.firstName} ${d.lastName}`.trim(),
        dateOfBirth: d.dateOfBirth || undefined,
        licenseNumber: d.licenseNumber || undefined,
        licenseState: d.licenseState || undefined,
      })),
      coverages: normalizeHawkSoftCoverages(hsCoverages),
    };
  } catch (error) {
    console.error('[Baseline] HawkSoft API enrichment failed:', error);
    return null;
  }
}


// ============================================================================
// FILE: src/lib/al3/comparison-engine.ts
// ============================================================================

/**
 * Comparison Engine
 * =================
 * Compares renewal offer against HawkSoft baseline.
 * Detects material changes and generates recommendation.
 */

import type {
  RenewalSnapshot,
  BaselineSnapshot,
  ComparisonResult,
  ComparisonSummary,
  MaterialChange,
  ComparisonThresholds,
  CanonicalCoverage,
  CanonicalVehicle,
  CanonicalDiscount,
  CanonicalEndorsement,
  CanonicalClaim,
  ChangeSeverity,
} from '@/types/renewal.types';
import { DEFAULT_COMPARISON_THRESHOLDS } from '@/types/renewal.types';
import { VEHICLE_LEVEL_COVERAGE_TYPES } from './constants';

// =============================================================================
// HELPERS
// =============================================================================

/**
 * Collect POLICY-LEVEL coverages (excluding vehicle-specific ones like Comp, Coll).
 * For auto policies, HawkSoft may return coverages at the policy level while
 * AL3 puts them at the vehicle level. This flattens policy-level coverages only,
 * deduplicating by coverage type.
 * Vehicle-specific coverages (Comp, Coll, Roadside, Rental) are compared per-vehicle.
 */
function collectPolicyLevelCoverages(
  policyCoverages: CanonicalCoverage[],
  vehicles: CanonicalVehicle[]
): CanonicalCoverage[] {
  // Filter to only policy-level coverages (exclude vehicle-specific)
  const policyLevel = policyCoverages.filter(c => !VEHICLE_LEVEL_COVERAGE_TYPES.has(c.type));

  // If we have policy-level coverages, return them
  if (policyLevel.length > 0) return policyLevel;

  // Otherwise, extract policy-level coverages from vehicles and deduplicate
  const seen = new Map<string, CanonicalCoverage>();
  for (const vehicle of vehicles) {
    for (const cov of vehicle.coverages || []) {
      // Skip vehicle-specific coverages
      if (cov.type && !seen.has(cov.type) && !VEHICLE_LEVEL_COVERAGE_TYPES.has(cov.type)) {
        seen.set(cov.type, cov);
      }
    }
  }
  return Array.from(seen.values());
}

/**
 * Collect ALL vehicle-level coverages from a snapshot (from vehicles or policy-level).
 * HawkSoft stores vehicle-level coverages at the policy level, while AL3 puts them on vehicles.
 * This collects them from wherever they exist.
 */
function collectVehicleLevelCoverages(
  policyCoverages: CanonicalCoverage[],
  vehicles: CanonicalVehicle[]
): CanonicalCoverage[] {
  const seen = new Map<string, CanonicalCoverage>();

  // Check policy-level coverages for vehicle-level types (HawkSoft style)
  for (const cov of policyCoverages) {
    if (cov.type && VEHICLE_LEVEL_COVERAGE_TYPES.has(cov.type) && !seen.has(cov.type)) {
      seen.set(cov.type, cov);
    }
  }

  // Check vehicle coverages (AL3 style)
  for (const vehicle of vehicles) {
    for (const cov of vehicle.coverages || []) {
      if (cov.type && VEHICLE_LEVEL_COVERAGE_TYPES.has(cov.type) && !seen.has(cov.type)) {
        seen.set(cov.type, cov);
      }
    }
  }

  return Array.from(seen.values());
}

/**
 * Compare vehicle-level coverages at the aggregate level.
 * Only checks for presence/absence - detailed per-vehicle comparison happens in compareVehicles.
 */
function compareVehicleLevelCoverages(
  renewalCoverages: CanonicalCoverage[],
  baselineCoverages: CanonicalCoverage[]
): MaterialChange[] {
  const changes: MaterialChange[] = [];

  const renewalByType = new Map(renewalCoverages.map((c) => [c.type, c]));
  const baselineByType = new Map(baselineCoverages.map((c) => [c.type, c]));

  // Check for removed vehicle-level coverages
  for (const [type, baseline] of baselineByType) {
    if (!renewalByType.has(type)) {
      changes.push({
        field: `coverage.${type}`,
        category: 'coverage_removed',
        classification: 'material_negative',
        oldValue: baseline.description || type,
        newValue: null,
        severity: 'material_negative',
        description: `Coverage removed: ${baseline.description || type}`,
      });
    }
  }

  // Check for added vehicle-level coverages
  for (const [type, renewal] of renewalByType) {
    if (!baselineByType.has(type)) {
      changes.push({
        field: `coverage.${type}`,
        category: 'coverage_added',
        classification: 'material_positive',
        oldValue: null,
        newValue: renewal.description || type,
        severity: 'material_positive',
        description: `Coverage added: ${renewal.description || type}`,
      });
    }
  }

  // Note: Detailed limit/deductible comparison happens per-vehicle in compareVehicles

  return changes;
}

// =============================================================================
// MAIN COMPARISON
// =============================================================================

/**
 * Compare a renewal snapshot against a baseline snapshot.
 */
export function compareSnapshots(
  renewal: RenewalSnapshot,
  baseline: BaselineSnapshot,
  thresholds: ComparisonThresholds = DEFAULT_COMPARISON_THRESHOLDS,
  renewalEffectiveDate?: string // ISO date string (YYYY-MM-DD)
): ComparisonResult {
  const allChanges: MaterialChange[] = [];

  // Detect stale baseline: baseline policy dates match renewal effective date
  const { baselineStatus, baselineStatusReason } = detectStaleBaseline(
    baseline,
    renewalEffectiveDate,
    renewal.premium
  );

  // Compare premium
  allChanges.push(...comparePremium(renewal.premium, baseline.premium, thresholds));

  // For auto policies, coverages may live at the vehicle level in one snapshot
  // but at the policy level in the other. Collect POLICY-LEVEL coverages only.
  // Vehicle-specific coverages (Comp, Coll, etc.) are compared separately.
  const renewalCoverages = collectPolicyLevelCoverages(renewal.coverages, renewal.vehicles);
  const baselineCoverages = collectPolicyLevelCoverages(baseline.coverages, baseline.vehicles);

  // Compare policy-level coverages (BI, PD, UM, MedPay, etc.)
  allChanges.push(...compareCoverages(renewalCoverages, baselineCoverages, thresholds));

  // Compare vehicle-level coverages at aggregate level (Comp, Coll, Roadside, Rental)
  // HawkSoft stores these at policy level, AL3 puts them on vehicles
  const renewalVehicleCovs = collectVehicleLevelCoverages(renewal.coverages, renewal.vehicles);
  const baselineVehicleCovs = collectVehicleLevelCoverages(baseline.coverages, baseline.vehicles);
  allChanges.push(...compareVehicleLevelCoverages(renewalVehicleCovs, baselineVehicleCovs));

  // Compare vehicles (includes vehicle-level coverage comparison)
  allChanges.push(...compareVehicles(renewal.vehicles, baseline.vehicles, thresholds));

  // Compare drivers
  allChanges.push(...compareDrivers(renewal.drivers, baseline.drivers));

  // Compare discounts
  allChanges.push(...compareDiscounts(renewal.discounts, baseline.discounts));

  // Compare endorsements
  allChanges.push(...compareEndorsements(renewal.endorsements, baseline.endorsements));

  // Compare claims
  allChanges.push(...compareClaims(renewal.claims, baseline.claims));

  // Flag property concerns (homeowners)
  allChanges.push(...flagPropertyConcerns(renewal, baseline));

  // When baseline is stale (current_term), downgrade all changes to non-material
  // since we're comparing the same term data and differences are unreliable
  if (baselineStatus === 'current_term') {
    for (const change of allChanges) {
      change.severity = 'non_material';
      change.classification = 'non_material';
    }
  }

  // Separate material vs non-material
  const materialChanges = allChanges.filter((c) => c.severity !== 'non_material');
  const nonMaterialChanges = allChanges.filter((c) => c.severity === 'non_material');

  // Generate summary
  const summary = buildSummary(renewal, baseline, materialChanges, nonMaterialChanges);

  // Generate recommendation
  const recommendation = generateRecommendation(materialChanges, renewal, thresholds, baselineStatus);

  // Determine confidence
  const confidenceLevel = getConfidenceLevel(renewal.parseConfidence);

  return {
    recommendation,
    summary,
    materialChanges,
    nonMaterialChanges,
    confidenceLevel,
    baselineStatus,
    baselineStatusReason,
  };
}

/**
 * Detect if the baseline is stale (captured from new term instead of prior term).
 */
function detectStaleBaseline(
  baseline: BaselineSnapshot,
  renewalEffectiveDate?: string,
  renewalPremium?: number
): { baselineStatus: 'prior_term' | 'current_term' | 'unknown'; baselineStatusReason?: string } {
  // If we don't have baseline policy dates, we can't determine
  if (!baseline.policyEffectiveDate) {
    // Fallback: if premiums are exactly equal, it's suspicious
    if (baseline.premium != null && renewalPremium != null && baseline.premium === renewalPremium) {
      return {
        baselineStatus: 'current_term',
        baselineStatusReason: 'Baseline premium equals renewal premium - prior term data may be unavailable',
      };
    }
    return { baselineStatus: 'unknown' };
  }

  // Compare baseline effective date with renewal effective date
  if (renewalEffectiveDate) {
    const baselineEffDate = baseline.policyEffectiveDate;
    const renewalEffDate = renewalEffectiveDate.split('T')[0]; // Normalize to YYYY-MM-DD

    if (baselineEffDate === renewalEffDate) {
      return {
        baselineStatus: 'current_term',
        baselineStatusReason: 'Baseline was captured from the new term - prior term data unavailable',
      };
    }
  }

  // Baseline effective date is different from renewal effective date - good!
  return { baselineStatus: 'prior_term' };
}

// =============================================================================
// PREMIUM COMPARISON
// =============================================================================

function comparePremium(
  renewalPremium: number | undefined,
  baselinePremium: number | undefined,
  thresholds: ComparisonThresholds
): MaterialChange[] {
  if (renewalPremium == null || baselinePremium == null) return [];

  const changeAmount = renewalPremium - baselinePremium;
  const changePercent = baselinePremium !== 0
    ? (changeAmount / baselinePremium) * 100
    : 0;

  let severity: ChangeSeverity;
  if (changeAmount < 0) {
    severity = 'material_positive'; // Decrease is positive
  } else if (
    changePercent > thresholds.premiumIncreasePercent ||
    changeAmount > thresholds.premiumIncreaseAmount
  ) {
    severity = 'material_negative';
  } else {
    severity = 'non_material';
  }

  return [{
    field: 'premium',
    category: 'premium',
    classification: severity,
    oldValue: baselinePremium,
    newValue: renewalPremium,
    changeAmount,
    changePercent: Math.round(changePercent * 100) / 100,
    severity,
    description: changeAmount === 0
      ? 'Premium unchanged'
      : changeAmount > 0
        ? `Premium increased by $${Math.abs(changeAmount).toFixed(2)} (${Math.abs(changePercent).toFixed(1)}%)`
        : `Premium decreased by $${Math.abs(changeAmount).toFixed(2)} (${Math.abs(changePercent).toFixed(1)}%)`,
  }];
}

// =============================================================================
// COVERAGE COMPARISON
// =============================================================================

// Major coverage types that are essential - removal is significant
const MAJOR_COVERAGE_TYPES = new Set([
  'bodily_injury', 'property_damage', 'dwelling', 'personal_liability',
  'uninsured_motorist', 'underinsured_motorist', 'personal_property',
  'other_structures', 'loss_of_use', 'medical_payments',
]);

function compareCoverages(
  renewalCoverages: CanonicalCoverage[],
  baselineCoverages: CanonicalCoverage[],
  thresholds: ComparisonThresholds
): MaterialChange[] {
  const changes: MaterialChange[] = [];

  const renewalByType = new Map(renewalCoverages.map((c) => [c.type, c]));
  const baselineByType = new Map(baselineCoverages.map((c) => [c.type, c]));

  // Check for removed coverages
  // Note: Coverage changes are INFORMATIONAL - they help explain premium changes
  // Only major coverage gaps are flagged for review, not reshop triggers
  for (const [type, baseline] of baselineByType) {
    if (!renewalByType.has(type)) {
      const isMajor = MAJOR_COVERAGE_TYPES.has(type);
      changes.push({
        field: `coverage.${type}`,
        category: 'coverage_removed',
        classification: isMajor ? 'material_negative' : 'non_material',
        oldValue: baseline.description || type,
        newValue: null,
        severity: isMajor ? 'material_negative' : 'non_material',
        description: `Coverage removed: ${baseline.description || type}`,
      });
    }
  }

  // Check for added coverages (always positive/informational)
  for (const [type, renewal] of renewalByType) {
    if (!baselineByType.has(type)) {
      changes.push({
        field: `coverage.${type}`,
        category: 'coverage_added',
        classification: 'non_material', // Added coverages are informational
        oldValue: null,
        newValue: renewal.description || type,
        severity: 'non_material',
        description: `Coverage added: ${renewal.description || type}`,
      });
    }
  }

  // Compare matching coverages
  for (const [type, renewal] of renewalByType) {
    const baseline = baselineByType.get(type);
    if (!baseline) continue;

    // Compare limits
    if (renewal.limitAmount != null && baseline.limitAmount != null) {
      const limitChange = renewal.limitAmount - baseline.limitAmount;
      const limitChangePercent = baseline.limitAmount !== 0
        ? (limitChange / baseline.limitAmount) * 100
        : 0;

      if (limitChange !== 0) {
        let severity: ChangeSeverity;
        if (limitChange < 0 && Math.abs(limitChangePercent) > thresholds.coverageLimitReductionPercent) {
          severity = 'material_negative';
        } else if (limitChange > 0) {
          severity = 'material_positive';
        } else {
          severity = 'non_material';
        }

        changes.push({
          field: `coverage.${type}.limit`,
          category: 'coverage_limit',
          classification: severity,
          oldValue: baseline.limitAmount,
          newValue: renewal.limitAmount,
          changeAmount: limitChange,
          changePercent: Math.round(limitChangePercent * 100) / 100,
          severity,
          description: `${renewal.description || type} limit ${limitChange > 0 ? 'increased' : 'decreased'} by ${Math.abs(limitChangePercent).toFixed(1)}%`,
        });
      }
    }

    // Compare deductibles
    if (renewal.deductibleAmount != null && baseline.deductibleAmount != null) {
      const dedChange = renewal.deductibleAmount - baseline.deductibleAmount;
      const dedChangePercent = baseline.deductibleAmount !== 0
        ? (dedChange / baseline.deductibleAmount) * 100
        : 0;

      if (dedChange !== 0) {
        let severity: ChangeSeverity;
        if (dedChange > 0 && dedChangePercent > thresholds.deductibleIncreasePercent) {
          severity = 'material_negative';
        } else if (dedChange < 0) {
          severity = 'material_positive';
        } else {
          severity = 'non_material';
        }

        changes.push({
          field: `coverage.${type}.deductible`,
          category: 'deductible',
          classification: severity,
          oldValue: baseline.deductibleAmount,
          newValue: renewal.deductibleAmount,
          changeAmount: dedChange,
          changePercent: Math.round(dedChangePercent * 100) / 100,
          severity,
          description: `${renewal.description || type} deductible ${dedChange > 0 ? 'increased' : 'decreased'} by ${Math.abs(dedChangePercent).toFixed(1)}%`,
        });
      }
    }
  }

  return changes;
}

// =============================================================================
// VEHICLE COMPARISON
// =============================================================================

function compareVehicles(
  renewalVehicles: CanonicalVehicle[],
  baselineVehicles: CanonicalVehicle[],
  thresholds: ComparisonThresholds = DEFAULT_COMPARISON_THRESHOLDS
): MaterialChange[] {
  const changes: MaterialChange[] = [];

  // Match by VIN first, then by year/make/model
  const renewalByVin = new Map(
    renewalVehicles.filter((v) => v.vin).map((v) => [v.vin!, v])
  );
  const baselineByVin = new Map(
    baselineVehicles.filter((v) => v.vin).map((v) => [v.vin!, v])
  );

  // Check for removed vehicles
  for (const [vin, baseline] of baselineByVin) {
    if (!renewalByVin.has(vin)) {
      const desc = `${baseline.year || ''} ${baseline.make || ''} ${baseline.model || ''}`.trim();
      changes.push({
        field: `vehicle.${vin}`,
        category: 'vehicle_removed',
        classification: 'material_negative',
        oldValue: desc || vin,
        newValue: null,
        severity: 'material_negative',
        description: `Vehicle removed: ${desc || vin}`,
      });
    }
  }

  // Check for added vehicles
  for (const [vin, renewal] of renewalByVin) {
    if (!baselineByVin.has(vin)) {
      const desc = `${renewal.year || ''} ${renewal.make || ''} ${renewal.model || ''}`.trim();
      changes.push({
        field: `vehicle.${vin}`,
        category: 'vehicle_added',
        classification: 'material_positive',
        oldValue: null,
        newValue: desc || vin,
        severity: 'material_positive',
        description: `Vehicle added: ${desc || vin}`,
      });
    }
  }

  // Compare coverages within matched vehicles
  // Note: Coverage presence/absence is handled by compareVehicleLevelCoverages at aggregate level
  // Here we only compare deductibles/limits for coverages that exist on BOTH vehicle records
  for (const [vin, renewalVeh] of renewalByVin) {
    const baselineVeh = baselineByVin.get(vin);
    if (!baselineVeh) continue;

    const vehDesc = `${renewalVeh.year || ''} ${renewalVeh.make || ''} ${renewalVeh.model || ''}`.trim();

    // Get vehicle-level coverages only
    const renewalCovs = (renewalVeh.coverages || []).filter(c => VEHICLE_LEVEL_COVERAGE_TYPES.has(c.type));
    const baselineCovs = (baselineVeh.coverages || []).filter(c => VEHICLE_LEVEL_COVERAGE_TYPES.has(c.type));

    const renewalByType = new Map(renewalCovs.map(c => [c.type, c]));
    const baselineByType = new Map(baselineCovs.map(c => [c.type, c]));

    // Compare matching coverages (deductibles, limits) - only where both vehicles have the coverage
    for (const [type, renewal] of renewalByType) {
      const baseline = baselineByType.get(type);
      if (!baseline) continue;

      // Compare deductibles
      if (renewal.deductibleAmount != null && baseline.deductibleAmount != null) {
        const dedChange = renewal.deductibleAmount - baseline.deductibleAmount;
        const dedChangePercent = baseline.deductibleAmount !== 0
          ? (dedChange / baseline.deductibleAmount) * 100
          : 0;

        if (dedChange !== 0) {
          let severity: ChangeSeverity;
          if (dedChange > 0 && dedChangePercent > thresholds.deductibleIncreasePercent) {
            severity = 'material_negative';
          } else if (dedChange < 0) {
            severity = 'material_positive';
          } else {
            severity = 'non_material';
          }

          changes.push({
            field: `vehicle.${vin}.coverage.${type}.deductible`,
            category: 'deductible',
            classification: severity,
            oldValue: baseline.deductibleAmount,
            newValue: renewal.deductibleAmount,
            changeAmount: dedChange,
            changePercent: Math.round(dedChangePercent * 100) / 100,
            severity,
            description: `${vehDesc} ${renewal.description || type} deductible: $${baseline.deductibleAmount} → $${renewal.deductibleAmount}`,
          });
        }
      }

      // Compare limits (for rental, roadside, etc.)
      if (renewal.limitAmount != null && baseline.limitAmount != null) {
        const limitChange = renewal.limitAmount - baseline.limitAmount;
        const limitChangePercent = baseline.limitAmount !== 0
          ? (limitChange / baseline.limitAmount) * 100
          : 0;

        if (limitChange !== 0) {
          let severity: ChangeSeverity;
          if (limitChange < 0 && Math.abs(limitChangePercent) > thresholds.coverageLimitReductionPercent) {
            severity = 'material_negative';
          } else if (limitChange > 0) {
            severity = 'material_positive';
          } else {
            severity = 'non_material';
          }

          changes.push({
            field: `vehicle.${vin}.coverage.${type}.limit`,
            category: 'coverage_limit',
            classification: severity,
            oldValue: baseline.limitAmount,
            newValue: renewal.limitAmount,
            changeAmount: limitChange,
            changePercent: Math.round(limitChangePercent * 100) / 100,
            severity,
            description: `${vehDesc} ${renewal.description || type} limit: $${baseline.limitAmount} → $${renewal.limitAmount}`,
          });
        }
      }
    }
  }

  return changes;
}

// =============================================================================
// DRIVER COMPARISON
// =============================================================================

/**
 * Normalize driver name for comparison.
 * Removes middle initials and extra spaces so "Ladonna B Lee" matches "Ladonna Lee".
 */
function normalizeDriverName(name: string): string {
  const cleaned = name
    .toLowerCase()
    .trim()
    // Remove single-letter middle initials (e.g., "John A Smith" -> "John Smith")
    .replace(/\s+[a-z]\s+/g, ' ')
    // Remove trailing single letter (e.g., "John Smith A" -> "John Smith")
    .replace(/\s+[a-z]$/g, '')
    // Collapse multiple spaces
    .replace(/\s+/g, ' ');
  // Sort name parts so "Smith John" matches "John Smith"
  return cleaned.split(' ').sort().join(' ');
}

function compareDrivers(
  renewalDrivers: import('@/types/renewal.types').CanonicalDriver[],
  baselineDrivers: import('@/types/renewal.types').CanonicalDriver[]
): MaterialChange[] {
  const changes: MaterialChange[] = [];

  // Build maps using normalized names for matching
  const renewalByNormalized = new Map(
    renewalDrivers.filter((d) => d.name).map((d) => [normalizeDriverName(d.name!), d])
  );
  const baselineByNormalized = new Map(
    baselineDrivers.filter((d) => d.name).map((d) => [normalizeDriverName(d.name!), d])
  );

  for (const [normalizedName, baseline] of baselineByNormalized) {
    if (!renewalByNormalized.has(normalizedName)) {
      const displayName = baseline.name || normalizedName;
      changes.push({
        field: `driver.${normalizedName}`,
        category: 'driver_removed',
        classification: 'material_negative',
        oldValue: displayName,
        newValue: null,
        severity: 'material_negative',
        description: `Driver removed: ${displayName}`,
      });
    }
  }

  for (const [normalizedName, renewal] of renewalByNormalized) {
    if (!baselineByNormalized.has(normalizedName)) {
      const displayName = renewal.name || normalizedName;
      changes.push({
        field: `driver.${normalizedName}`,
        category: 'driver_added',
        classification: 'material_positive',
        oldValue: null,
        newValue: displayName,
        severity: 'material_positive',
        description: `Driver added: ${displayName}`,
      });
    }
  }

  return changes;
}

// =============================================================================
// DISCOUNT COMPARISON
// =============================================================================

function compareDiscounts(
  renewalDiscounts: CanonicalDiscount[],
  baselineDiscounts: CanonicalDiscount[]
): MaterialChange[] {
  const changes: MaterialChange[] = [];

  const renewalByCode = new Map(renewalDiscounts.map((d) => [d.code.toUpperCase(), d]));
  const baselineByCode = new Map(baselineDiscounts.map((d) => [d.code.toUpperCase(), d]));

  // Removed discounts (in baseline but not in renewal) — lost a savings
  for (const [code, baseline] of baselineByCode) {
    if (!renewalByCode.has(code)) {
      changes.push({
        field: `discount.${code}`,
        category: 'discount_removed',
        classification: 'material_negative',
        oldValue: baseline.description || code,
        newValue: null,
        severity: 'material_negative',
        description: `Discount removed: ${baseline.description || code}`,
      });
    }
  }

  // Added discounts (in renewal but not in baseline)
  for (const [code, renewal] of renewalByCode) {
    if (!baselineByCode.has(code)) {
      changes.push({
        field: `discount.${code}`,
        category: 'discount_added',
        classification: 'material_positive',
        oldValue: null,
        newValue: renewal.description || code,
        severity: 'material_positive',
        description: `Discount added: ${renewal.description || code}`,
      });
    }
  }

  return changes;
}

// =============================================================================
// ENDORSEMENT COMPARISON
// =============================================================================

function compareEndorsements(
  renewalEndorsements: CanonicalEndorsement[],
  baselineEndorsements: CanonicalEndorsement[]
): MaterialChange[] {
  const changes: MaterialChange[] = [];

  const renewalByCode = new Map(renewalEndorsements.map((e) => [e.code.toUpperCase(), e]));
  const baselineByCode = new Map(baselineEndorsements.map((e) => [e.code.toUpperCase(), e]));

  // Removed endorsements
  for (const [code, baseline] of baselineByCode) {
    if (!renewalByCode.has(code)) {
      changes.push({
        field: `endorsement.${code}`,
        category: 'endorsement_removed',
        classification: 'material_negative',
        oldValue: baseline.description || code,
        newValue: null,
        severity: 'material_negative',
        description: `Endorsement removed: ${baseline.description || code}`,
      });
    }
  }

  // Added endorsements — flag for agent review (can be positive or negative)
  for (const [code, renewal] of renewalByCode) {
    if (!baselineByCode.has(code)) {
      changes.push({
        field: `endorsement.${code}`,
        category: 'endorsement_added',
        classification: 'non_material',
        oldValue: null,
        newValue: renewal.description || code,
        severity: 'non_material',
        description: `Endorsement added: ${renewal.description || code}`,
      });
    }
  }

  return changes;
}

// =============================================================================
// CLAIM COMPARISON
// =============================================================================

function compareClaims(
  renewalClaims: CanonicalClaim[],
  baselineClaims: CanonicalClaim[]
): MaterialChange[] {
  const changes: MaterialChange[] = [];

  const baselineClaimNumbers = new Set(
    baselineClaims
      .filter((c) => c.claimNumber)
      .map((c) => c.claimNumber!.toUpperCase())
  );

  // New claims in renewal that aren't in baseline
  for (const claim of renewalClaims) {
    const key = claim.claimNumber?.toUpperCase();
    if (key && baselineClaimNumbers.has(key)) continue;

    const datePart = claim.claimDate ? ` on ${claim.claimDate}` : '';
    const amountPart = claim.amount != null ? ` — $${claim.amount.toLocaleString()}` : '';
    const typePart = claim.claimType || 'Unknown type';

    changes.push({
      field: `claim.${claim.claimNumber || 'new'}`,
      category: 'claim',
      classification: 'material_negative',
      oldValue: null,
      newValue: claim.claimNumber || typePart,
      severity: 'material_negative',
      description: `New claim: ${typePart}${datePart}${amountPart}`,
    });
  }

  return changes;
}

// =============================================================================
// PROPERTY CONCERNS (HOMEOWNERS)
// =============================================================================

function flagPropertyConcerns(
  renewal: RenewalSnapshot,
  baseline: BaselineSnapshot
): MaterialChange[] {
  const changes: MaterialChange[] = [];
  const propertyContext = baseline.propertyContext;

  if (!propertyContext) return changes;

  // Roof age flags
  if (propertyContext.roofAge != null) {
    const roofDesc = propertyContext.roofType
      ? `${propertyContext.roofAge} years (${propertyContext.roofType})`
      : `${propertyContext.roofAge} years`;

    if (propertyContext.roofAge >= 20) {
      changes.push({
        field: 'property.roofAge',
        category: 'property',
        classification: 'material_negative',
        oldValue: propertyContext.roofAge,
        newValue: propertyContext.roofAge,
        severity: 'material_negative',
        description: `Roof age ${roofDesc} may affect coverage eligibility`,
      });
    } else if (propertyContext.roofAge >= 15) {
      changes.push({
        field: 'property.roofAge',
        category: 'property',
        classification: 'non_material',
        oldValue: propertyContext.roofAge,
        newValue: propertyContext.roofAge,
        severity: 'non_material',
        description: `Roof age: ${roofDesc}`,
      });
    }
  }

  // Check dwelling coverage (COV_A/dwelling) for RCE changes
  const renewalDwelling = renewal.coverages.find((c) => c.type === 'dwelling');
  const baselineDwelling = baseline.coverages.find((c) => c.type === 'dwelling');
  if (
    renewalDwelling?.limitAmount != null &&
    baselineDwelling?.limitAmount != null &&
    renewalDwelling.limitAmount !== baselineDwelling.limitAmount
  ) {
    changes.push({
      field: 'property.rce',
      category: 'property',
      classification:
        renewalDwelling.limitAmount < baselineDwelling.limitAmount
          ? 'material_negative'
          : 'non_material',
      oldValue: baselineDwelling.limitAmount,
      newValue: renewalDwelling.limitAmount,
      changeAmount: renewalDwelling.limitAmount - baselineDwelling.limitAmount,
      severity:
        renewalDwelling.limitAmount < baselineDwelling.limitAmount
          ? 'material_negative'
          : 'non_material',
      description: `Replacement Cost Estimate changed: $${baselineDwelling.limitAmount.toLocaleString()} → $${renewalDwelling.limitAmount.toLocaleString()}`,
    });
  }

  // Check for valuation method change (Replacement Cost → ACV)
  const baselineDesc = baselineDwelling?.description?.toLowerCase() || '';
  const renewalDesc = renewalDwelling?.description?.toLowerCase() || '';
  const baselineIsRC =
    baselineDesc.includes('replacement cost') || baselineDesc.includes('rc');
  const renewalIsACV =
    renewalDesc.includes('actual cash value') || renewalDesc.includes('acv');

  if (baselineIsRC && renewalIsACV) {
    changes.push({
      field: 'property.roofCoverageType',
      category: 'property',
      classification: 'material_negative',
      oldValue: 'Replacement Cost',
      newValue: 'Actual Cash Value',
      severity: 'material_negative',
      description: 'Roof coverage changed from Replacement Cost to Actual Cash Value',
    });
  }

  return changes;
}

// =============================================================================
// SUMMARY & RECOMMENDATION
// =============================================================================

function buildSummary(
  renewal: RenewalSnapshot,
  baseline: BaselineSnapshot,
  materialChanges: MaterialChange[],
  nonMaterialChanges: MaterialChange[]
): ComparisonSummary {
  const premiumChange = materialChanges.find((c) => c.category === 'premium') ||
    nonMaterialChanges.find((c) => c.category === 'premium');

  const premiumDirection: 'increase' | 'decrease' | 'same' =
    (premiumChange?.changeAmount ?? 0) > 0
      ? 'increase'
      : (premiumChange?.changeAmount ?? 0) < 0
        ? 'decrease'
        : 'same';

  const materialNegativeCount = materialChanges.filter((c) => c.severity === 'material_negative').length;
  const materialPositiveCount = materialChanges.filter((c) => c.severity === 'material_positive').length;

  let headline: string;
  if (materialNegativeCount === 0 && premiumDirection !== 'increase') {
    headline = 'Renewal looks favorable - no material negative changes';
  } else if (materialNegativeCount > 0) {
    headline = `${materialNegativeCount} material concern${materialNegativeCount > 1 ? 's' : ''} detected`;
  } else {
    headline = 'Renewal review needed';
  }

  return {
    premiumDirection,
    premiumChangeAmount: premiumChange?.changeAmount,
    premiumChangePercent: premiumChange?.changePercent,
    materialNegativeCount,
    materialPositiveCount,
    nonMaterialCount: nonMaterialChanges.length,
    headline,
  };
}

function generateRecommendation(
  materialChanges: MaterialChange[],
  renewal: RenewalSnapshot,
  thresholds: ComparisonThresholds,
  baselineStatus?: 'prior_term' | 'current_term' | 'unknown'
): 'renew_as_is' | 'reshop' | 'needs_review' {
  // Stale baseline = can't make reliable recommendation
  if (baselineStatus === 'current_term') {
    return 'needs_review';
  }

  if (renewal.parseConfidence < 0.5) {
    return 'needs_review'; // Low confidence = manual review
  }

  // PRIMARY TRIGGER: Premium change
  // The main purpose of this tool is current rate vs renewal rate comparison
  const premiumChange = materialChanges.find((c) => c.category === 'premium');
  const premiumIncreasePercent = premiumChange?.changePercent ?? 0;
  const premiumIncreaseAmount = premiumChange?.changeAmount ?? 0;

  // Significant premium increase → reshop
  if (
    premiumIncreasePercent >= thresholds.premiumIncreasePercent ||
    premiumIncreaseAmount >= thresholds.premiumIncreaseAmount
  ) {
    return 'reshop';
  }

  // SECONDARY: Coverage gaps (only if premium is flat/decreased but coverage worsened)
  // These are informational to help agents understand WHY premium changed
  // Only trigger reshop for major coverage gaps when premium didn't go up
  const coverageRemovals = materialChanges.filter(
    (c) => c.category === 'coverage_removed' && c.severity === 'material_negative'
  );
  const majorCoverageTypes = ['bodily_injury', 'property_damage', 'dwelling', 'personal_liability'];
  const hasMajorCoverageRemoval = coverageRemovals.some((c) =>
    majorCoverageTypes.some((t) => c.description?.toLowerCase().includes(t.replace('_', ' ')))
  );

  // If major coverage removed AND premium stayed same/decreased, that's suspicious
  if (hasMajorCoverageRemoval && premiumIncreasePercent <= 0) {
    return 'needs_review'; // Not reshop, just needs agent attention
  }

  // Significant premium decrease with ANY coverage removals is suspicious
  // (e.g., -25% because sewer backup / equipment breakdown were dropped)
  if (premiumIncreasePercent <= -15 && coverageRemovals.length > 0) {
    return 'needs_review';
  }

  // Premium flat or decreased with no major issues → renew as is
  return 'renew_as_is';
}

function getConfidenceLevel(parseConfidence: number): 'high' | 'medium' | 'low' {
  if (parseConfidence >= 0.8) return 'high';
  if (parseConfidence >= 0.5) return 'medium';
  return 'low';
}


// ============================================================================
// FILE: src/lib/al3/zip-extractor.ts
// ============================================================================

/**
 * ZIP Extractor
 * =============
 * Recursively extracts AL3 files from ZIP archives (including nested ZIPs).
 */

import type { ExtractedAL3File } from '@/types/renewal.types';

// =============================================================================
// CONTENT SNIFFING
// =============================================================================

/**
 * Check if content looks like an AL3 file (text-based, has AL3 group codes).
 */
export function isAL3Content(content: string): boolean {
  // AL3 files should have transaction headers (2TRG) or master headers (1MHG)
  return content.includes('1MHG') || content.includes('2TRG');
}

/**
 * Check if a filename looks like an AL3 file.
 */
export function isAL3FileName(fileName: string): boolean {
  const lower = fileName.toLowerCase();
  return (
    lower.endsWith('.al3') ||
    lower.endsWith('.dat') ||
    lower.endsWith('.txt') ||
    lower.endsWith('.asc')
  );
}

/**
 * Check if a buffer starts with a ZIP magic number.
 */
export function isZipBuffer(buffer: Buffer): boolean {
  return buffer.length >= 4 && buffer[0] === 0x50 && buffer[1] === 0x4b;
}

// =============================================================================
// ZIP EXTRACTION
// =============================================================================

/**
 * Extract AL3 files from a ZIP buffer.
 * Recursively processes nested ZIPs up to maxDepth.
 *
 * Uses the built-in yauzl library for streaming ZIP extraction.
 */
export async function extractAL3FilesFromZip(
  buffer: Buffer,
  maxDepth: number = 3,
  currentDepth: number = 0,
  parentZip?: string
): Promise<ExtractedAL3File[]> {
  if (currentDepth > maxDepth) {
    console.warn(`[ZipExtractor] Max nesting depth (${maxDepth}) reached`);
    return [];
  }

  const yauzl = await import('yauzl');
  const files: ExtractedAL3File[] = [];

  return new Promise((resolve, reject) => {
    yauzl.fromBuffer(buffer, { lazyEntries: true }, (err, zipfile) => {
      if (err || !zipfile) {
        // Not a valid ZIP - check if it's raw AL3 content
        const content = buffer.toString('latin1');
        if (isAL3Content(content)) {
          resolve([{
            fileName: parentZip || 'raw-content.al3',
            content,
            sourceZip: parentZip,
            nestingDepth: currentDepth,
          }]);
        } else {
          resolve([]);
        }
        return;
      }

      const entries: Promise<ExtractedAL3File[]>[] = [];

      zipfile.readEntry();
      zipfile.on('entry', (entry) => {
        if (/\/$/.test(entry.fileName)) {
          // Directory entry, skip
          zipfile.readEntry();
          return;
        }

        const promise = new Promise<ExtractedAL3File[]>((resolveEntry) => {
          zipfile.openReadStream(entry, (err, readStream) => {
            if (err || !readStream) {
              resolveEntry([]);
              zipfile.readEntry();
              return;
            }

            const chunks: Buffer[] = [];
            readStream.on('data', (chunk: Buffer) => chunks.push(chunk));
            readStream.on('end', async () => {
              const entryBuffer = Buffer.concat(chunks);

              if (isZipBuffer(entryBuffer)) {
                // Nested ZIP - recurse
                const nested = await extractAL3FilesFromZip(
                  entryBuffer,
                  maxDepth,
                  currentDepth + 1,
                  entry.fileName
                );
                resolveEntry(nested);
              } else if (isAL3FileName(entry.fileName)) {
                // AL3 file
                const content = entryBuffer.toString('latin1');
                if (isAL3Content(content)) {
                  resolveEntry([{
                    fileName: entry.fileName,
                    content,
                    sourceZip: parentZip,
                    nestingDepth: currentDepth,
                  }]);
                } else {
                  resolveEntry([]);
                }
              } else {
                // Try content sniffing for files without AL3 extension
                const content = entryBuffer.toString('latin1');
                if (isAL3Content(content)) {
                  resolveEntry([{
                    fileName: entry.fileName,
                    content,
                    sourceZip: parentZip,
                    nestingDepth: currentDepth,
                  }]);
                } else {
                  resolveEntry([]);
                }
              }

              zipfile.readEntry();
            });
            readStream.on('error', () => {
              resolveEntry([]);
              zipfile.readEntry();
            });
          });
        });

        entries.push(promise);
      });

      zipfile.on('end', async () => {
        const allEntries = await Promise.all(entries);
        resolve(allEntries.flat());
      });

      zipfile.on('error', (err) => {
        console.error('[ZipExtractor] ZIP error:', err);
        resolve([]);
      });
    });
  });
}


// ============================================================================
// FILE: src/lib/al3/index.ts
// ============================================================================

/**
 * AL3 Parser Library - Barrel Exports
 */

export * from './constants';
export * from './parser';
export * from './filter';
export * from './snapshot-builder';
export * from './zip-extractor';
export * from './baseline-builder';
export * from './comparison-engine';


// ============================================================================
// FILE: src/app/api/renewals/internal/parse/route.ts
// ============================================================================

/**
 * POST /api/renewals/internal/parse
 * Parse AL3 content and return transactions/snapshots (called by worker).
 *
 * Accepts:
 *   { action: 'extract-zip', fileBuffer: string (base64) }
 *   { action: 'parse-file', content: string }
 *   { action: 'filter-renewals', transactions: any[] }
 *   { action: 'build-snapshot', transaction: any }
 */

import { NextRequest, NextResponse } from 'next/server';
import { extractAL3FilesFromZip } from '@/lib/al3/zip-extractor';
import { parseAL3File } from '@/lib/al3/parser';
import { filterRenewalTransactions, deduplicateRenewals, partitionTransactions } from '@/lib/al3/filter';
import { buildRenewalSnapshot } from '@/lib/al3/snapshot-builder';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    switch (body.action) {
      case 'extract-zip': {
        const buffer = Buffer.from(body.fileBuffer, 'base64');
        const files = await extractAL3FilesFromZip(buffer);
        return NextResponse.json({
          success: true,
          files: files.map((f) => ({ fileName: f.fileName, content: f.content })),
        });
      }

      case 'parse-file': {
        const transactions = parseAL3File(body.content);
        return NextResponse.json({ success: true, transactions });
      }

      case 'filter-renewals': {
        const renewals = filterRenewalTransactions(body.transactions);
        const { unique, duplicatesRemoved } = deduplicateRenewals(renewals);
        return NextResponse.json({ success: true, unique, duplicatesRemoved });
      }

      case 'partition-transactions': {
        const { renewals, nonRenewals } = partitionTransactions(body.transactions);
        const { unique: deduped, duplicatesRemoved } = deduplicateRenewals(renewals);

        // Filter out renewals whose effective date is today or in the past.
        // Once a policy has renewed, HawkSoft updates to the new term data,
        // so prior term data is no longer available for baseline comparison.
        const today = new Date().toISOString().split('T')[0];
        const unique = deduped.filter((r: any) => {
          const effDate = r.header?.effectiveDate?.split('T')[0];
          if (effDate && effDate <= today) {
            console.log(`[Parse] Skipping already-renewed policy ${r.header?.policyNumber} (eff ${effDate})`);
            return false;
          }
          return true;
        });
        const expiredSkipped = deduped.length - unique.length;

        console.log(`[Parse] partition-transactions — total=${body.transactions.length} renewals=${renewals.length} unique=${unique.length} duplicatesRemoved=${duplicatesRemoved} expiredSkipped=${expiredSkipped} nonRenewals=${nonRenewals.length}`);
        return NextResponse.json({ success: true, unique, duplicatesRemoved, nonRenewals });
      }

      case 'build-snapshot': {
        const snapshot = buildRenewalSnapshot(body.transaction);
        return NextResponse.json({ success: true, snapshot });
      }

      default:
        return NextResponse.json({ success: false, error: `Unknown action: ${body.action}` }, { status: 400 });
    }
  } catch (error) {
    console.error('[Internal API] Parse error:', error);
    return NextResponse.json(
      { success: false, error: error instanceof Error ? error.message : 'Parse failed' },
      { status: 500 }
    );
  }
}


// ============================================================================
// FILE: src/app/api/renewals/internal/baseline/route.ts
// ============================================================================

/**
 * POST /api/renewals/internal/baseline
 * Fetch baseline snapshot for a policy (called by worker).
 */

import { NextRequest, NextResponse } from 'next/server';
import { buildBaselineSnapshot } from '@/lib/al3/baseline-builder';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { tenantId, policyNumber, carrierName, renewalEffectiveDate } = body;

    if (!tenantId || !policyNumber) {
      return NextResponse.json(
        { success: false, error: 'tenantId and policyNumber are required' },
        { status: 400 }
      );
    }

    const result = await buildBaselineSnapshot(tenantId, policyNumber, carrierName, renewalEffectiveDate);

    if (!result) {
      return NextResponse.json({
        success: false,
        error: 'Policy not found',
      });
    }

    return NextResponse.json({
      success: true,
      snapshot: result.snapshot,
      policyId: result.policyId,
      customerId: result.customerId,
    });
  } catch (error) {
    console.error('[Internal API] Error fetching baseline:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to fetch baseline' },
      { status: 500 }
    );
  }
}


// ============================================================================
// FILE: src/app/api/renewals/internal/compare/route.ts
// ============================================================================

/**
 * POST /api/renewals/internal/compare
 * Run comparison engine on renewal vs baseline snapshots (called by worker).
 *
 * Accepts: { renewalSnapshot, baselineSnapshot, thresholds? }
 * Returns: { success, result: ComparisonResult }
 */

import { NextRequest, NextResponse } from 'next/server';
import { compareSnapshots } from '@/lib/al3/comparison-engine';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    if (!body.renewalSnapshot || !body.baselineSnapshot) {
      return NextResponse.json(
        { success: false, error: 'renewalSnapshot and baselineSnapshot are required' },
        { status: 400 }
      );
    }

    const result = compareSnapshots(
      body.renewalSnapshot,
      body.baselineSnapshot,
      body.thresholds,
      body.renewalEffectiveDate
    );

    return NextResponse.json({ success: true, result });
  } catch (error) {
    console.error('[Internal API] Compare error:', error);
    return NextResponse.json(
      { success: false, error: error instanceof Error ? error.message : 'Comparison failed' },
      { status: 500 }
    );
  }
}


// ============================================================================
// FILE: src/app/api/renewals/upload/route.ts
// ============================================================================

/**
 * POST /api/renewals/upload
 * Accept a ZIP file containing IVANS AL3 downloads.
 * Creates a batch record and queues processing.
 */

import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/db';
import { renewalBatches } from '@/db/schema';
import { eq } from 'drizzle-orm';
import { queueRenewalBatchProcessing } from '@/lib/queues/client';

const TENANT_ID = process.env.DEFAULT_TENANT_ID || '';
const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const file = formData.get('file') as File | null;
    const uploadedById = formData.get('uploadedById') as string | null;

    if (!file) {
      return NextResponse.json(
        { success: false, error: 'No file provided' },
        { status: 400 }
      );
    }

    if (file.size > MAX_FILE_SIZE) {
      return NextResponse.json(
        { success: false, error: 'File exceeds 100MB limit' },
        { status: 400 }
      );
    }

    // Store file in Supabase Storage (or local for dev)
    const buffer = Buffer.from(await file.arrayBuffer());
    const storagePath = `renewals/${Date.now()}-${file.name}`;

    // For now, we'll process in-memory and store reference
    // In production, upload to Supabase Storage first

    // Create batch record
    const [batch] = await db
      .insert(renewalBatches)
      .values({
        tenantId: TENANT_ID,
        uploadedById: uploadedById || null,
        originalFileName: file.name,
        fileSize: file.size,
        storagePath,
        status: 'uploaded',
      })
      .returning();

    // Queue for processing
    try {
      await queueRenewalBatchProcessing({
        batchId: batch.id,
        tenantId: TENANT_ID,
        storagePath,
        fileBuffer: buffer.toString('base64'), // Pass buffer for in-memory processing
      });
    } catch (queueError) {
      console.error('[Upload] Failed to queue batch processing:', queueError);
      // Update batch status to indicate queue failure
      await db
        .update(renewalBatches)
        .set({
          status: 'failed',
          errorMessage: 'Failed to queue for processing',
          updatedAt: new Date(),
        })
        .where(eq(renewalBatches.id, batch.id));

      return NextResponse.json({
        success: false,
        error: 'File uploaded but processing failed to start. Please try again or contact support.',
      }, { status: 500 });
    }

    return NextResponse.json({
      success: true,
      batchId: batch.id,
      fileName: file.name,
      fileSize: file.size,
    });
  } catch (error) {
    console.error('[API] Error uploading renewal batch:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to upload file' },
      { status: 500 }
    );
  }
}


